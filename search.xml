<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react扩展</title>
      <link href="/2022/01/27/react%E6%89%A9%E5%B1%95/"/>
      <url>/2022/01/27/react%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h3><h4 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h4><p>(1). setState(stateChange, [callback])——对象式的setState<br>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)<br>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</p><p>(2). setState(updater, [callback])——函数式的setState<br>        1.updater为返回stateChange对象的函数。<br>        2.updater可以接收到state和props。<br>        4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</p><p>总结:<br>        1.对象式的setState是函数式的setState的简写方式(语法糖)<br>        2.使用原则：<br>                (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式<br>                (2).如果新状态依赖于原状态 ===&gt; 使用函数方式<br>                (3).如果需要在setState()执行后获取最新的状态数据,<br>                    要在第二个callback函数中读取</p><h3 id="2-lazyLoad"><a href="#2-lazyLoad" class="headerlink" title="2. lazyLoad"></a>2. lazyLoad</h3><h4 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h4><p>1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包<br>const Login = lazy(()=&gt;import(‘@/pages/Login’))</p><p>2.通过&lt; Suspense &gt;指定在加载得到路由打包文件前显示一个自定义loading界面</p><pre class="line-numbers language-none"><code class="language-none">&lt;Suspense fallback&#x3D;&#123;&lt; h1 &gt;loading.....&lt;&#x2F; h1 &gt;&#125;&gt;    &lt; Switch &gt;        &lt; Route path&#x3D;&quot;&#x2F;xxx&quot; component&#x3D;&#123;Xxxx&#125;&#x2F; &gt;        &lt;Redirect to&#x3D;&quot;&#x2F;login&quot;&#x2F; &gt;    &lt; &#x2F;Switch &gt;&lt; &#x2F;Suspense &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h3><h4 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook/Hooks是什么?"></a>1. React Hook/Hooks是什么?</h4><p>(1). Hook是React 16.8.0版本增加的新特性/新语法<br>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</p><h4 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h4><p>(1). State Hook: React.useState()<br>(2). Effect Hook: React.useEffect()<br>(3). Ref Hook: React.useRef()</p><h4 id="3-State-Hook"><a href="#3-State-Hook" class="headerlink" title="3. State Hook"></a>3. State Hook</h4><p>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作<br>(2). 语法: const [xxx, setXxx] = React.useState(initValue)<br>(3). useState()说明:<br>        参数: 第一次初始化指定的值在内部作缓存<br>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数<br>(4). setXxx()2种写法:<br>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值<br>        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</p><h4 id="4-Effect-Hook"><a href="#4-Effect-Hook" class="headerlink" title="4. Effect Hook"></a>4. Effect Hook</h4><p>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)<br>(2). React中的副作用操作:<br>        发ajax请求数据获取<br>        设置订阅 / 启动定时器<br>        手动更改真实DOM<br>(3). 语法和说明: </p><pre class="line-numbers language-none"><code class="language-none">useEffect(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 在此可以执行任何带副作用操作    return () &#x3D;&gt; &#123; &#x2F;&#x2F; 在组件卸载前执行      &#x2F;&#x2F; 在此做一些收尾工作, 比如清除定时器&#x2F;取消订阅等    &#125;  &#125;, [stateValue]) &#x2F;&#x2F; 如果指定的是[], 回调函数只会在第一次render()后执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4). 可以把 useEffect Hook 看做如下三个函数的组合<br>        componentDidMount()<br>        componentDidUpdate()<br>        componentWillUnmount() </p><h4 id="5-Ref-Hook"><a href="#5-Ref-Hook" class="headerlink" title="5. Ref Hook"></a>5. Ref Hook</h4><p>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据<br>(2). 语法: const refContainer = useRef()<br>(3). 作用:保存标签对象,功能与React.createRef()一样</p><h3 id="4-Context"><a href="#4-Context" class="headerlink" title="4. Context"></a>4. Context</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">1. 创建Context容器对象：   const XxxContext &#x3D; React.createContext()  2. 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：   &lt;xxxContext.Provider value&#x3D;&#123;数据&#125;&gt;   子组件    &lt;&#x2F;xxxContext.Provider&gt;3. 后代组件读取数据：   &#x2F;&#x2F;第一种方式:仅适用于类组件      static contextType &#x3D; xxxContext  &#x2F;&#x2F; 声明接收context     this.context &#x2F;&#x2F; 读取context中的value数据   &#x2F;&#x2F;第二种方式: 函数组件与类组件都可以     &lt;xxxContext.Consumer&gt;       &#123;         value &#x3D;&gt; ( &#x2F;&#x2F; value就是context中的value数据           要显示的内容         )       &#125;     &lt;&#x2F;xxxContext.Consumer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在应用开发中一般不用context, 一般都用它的封装react插件</p><h3 id="5-组件优化"><a href="#5-组件优化" class="headerlink" title="5. 组件优化"></a>5. 组件优化</h3><h4 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h4><ol><li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render() ==&gt; 效率低</p></li><li><p>只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==&gt; 效率低</p></li></ol><h4 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h4><p>只有当组件的state或props数据发生改变时才重新render()</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>Component中的shouldComponentUpdate()总是返回true</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>办法1:<br>    重写shouldComponentUpdate()方法<br>    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false<br>办法2:<br>    使用PureComponent<br>    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true<br>    注意:<br>        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false<br>        不要直接修改state数据, 而是要产生新数据<br>项目中一般使用PureComponent来优化</p><h3 id="6-render-props"><a href="#6-render-props" class="headerlink" title="6. render props"></a>6. render props</h3><h4 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h4><p>Vue中:<br>    使用slot技术, 也就是通过组件标签体传入结构  &lt; A &gt;&lt; B/&gt;&lt; /A&gt;<br>React中:<br>    使用children props: 通过组件标签体传入结构<br>    使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性</p><h4 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h4><pre class="line-numbers language-none"><code class="language-none">&lt;A&gt;  &lt;B&gt;xxxx&lt;&#x2F;B&gt;&lt;&#x2F;A&gt;&#123;this.props.children&#125;问题: 如果B组件需要A组件内的数据, &#x3D;&#x3D;&gt; 做不到 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h4><p>&lt;A render={(data) =&gt; &lt; C data={data}&gt;&lt; /C &gt;}&gt;&lt; /A&gt;<br>A组件: {this.props.render(内部state数据)}<br>C组件: 读取A组件传入的数据显示 {this.props.data} </p><h3 id="7-错误边界"><a href="#7-错误边界" class="headerlink" title="7. 错误边界"></a>7. 错误边界</h3><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p><strong>getDerivedStateFromError配合componentDidCatch</strong></p><p>生命周期函数，一旦后台组件报错，就会触发</p><pre class="line-numbers language-none"><code class="language-none">static getDerivedStateFromError(error) &#123;    console.log(error);    &#x2F;&#x2F;在render之前触发    &#x2F;&#x2F;返回新的state    return &#123;        hasError: true,    &#125;;&#125;componentDidCatch(error, info) &#123;     &#x2F;&#x2F;统计页面的错误。发送请求发送到后台去    console.log(error, info);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-组件通信方式总结"><a href="#8-组件通信方式总结" class="headerlink" title="8. 组件通信方式总结"></a>8. 组件通信方式总结</h3><h4 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h4><ul><li>父子组件</li><li>兄弟组件（非嵌套组件）</li><li>祖孙组件（跨级组件）</li></ul><h4 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h4><h5 id="1-props："><a href="#1-props：" class="headerlink" title="1.props："></a>1.props：</h5><p>​    (1).children props<br>​    (2).render props</p><h5 id="2-消息订阅-发布："><a href="#2-消息订阅-发布：" class="headerlink" title="2.消息订阅-发布："></a>2.消息订阅-发布：</h5><p>​    pubs-sub、event等等</p><h5 id="3-集中式管理："><a href="#3-集中式管理：" class="headerlink" title="3.集中式管理："></a>3.集中式管理：</h5><p>​    redux、dva等等</p><h5 id="4-conText"><a href="#4-conText" class="headerlink" title="4.conText:"></a>4.conText:</h5><p>​    生产者-消费者模式</p><h4 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h4><p>​    父子组件：props<br>​    兄弟组件：消息订阅-发布、集中式管理<br>​    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux</title>
      <link href="/2022/01/18/redux/"/>
      <url>/2022/01/18/redux/</url>
      
        <content type="html"><![CDATA[<h4 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h4><h5 id="redux是什么"><a href="#redux是什么" class="headerlink" title="redux是什么"></a>redux是什么</h5><p>​                        1. redux是一个专门用于做<strong>状态管理</strong>的JS库(不是react插件库)。</p><p>​                        2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p><p>​                        3. 作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</p><h5 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h5><p>​                        1. 某个组件的状态，需要让其他组件可以随时拿到（共享）。</p><p>​                        2. 一个组件需要改变另一个组件的状态（通信）。</p><p>​                        3. 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</p><h5 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h5><p>​                    <img src="/2022/01/18/redux/redux.png" alt="redux"></p><h4 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h4><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><p>​                1. 动作的对象</p><p>​                2. 包含2个属性</p><p>​                        type：标识属性, 值为字符串, 唯一, 必要属性</p><p>​                        data：数据属性, 值类型任意, 可选属性</p><p>​                3. 例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</p><h5 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h5><p>​                1. 用于初始化状态、加工状态。</p><p>​                2. 加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</p><h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><p>​                1. 将state、action、reducer联系在一起的对象</p><p>​                2. 如何得到此对象?</p><p>​                       (1) import {createStore} from ‘redux’</p><p>​                       (2) import reducer from ‘./reducers’</p><p>​                       (3) const store = createStore(reducer)</p><p>​                3. 此对象的功能?</p><p>​                       (1) getState(): 得到state</p><p>​                       (2) dispatch(action): 分发action, 触发reducer调用, 产生新的state</p><p>​                       (3) subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p><h4 id="redux的核心API"><a href="#redux的核心API" class="headerlink" title="redux的核心API"></a>redux的核心API</h4><h5 id="createstore"><a href="#createstore" class="headerlink" title="createstore()"></a>createstore()</h5><p>​                   作用：创建包含指定reducer的store对象</p><h5 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h5><p>​                    1. 作用: redux库最核心的管理对象</p><p>​                    2. 它内部维护着:</p><p>​                                     (1) state</p><p>​                                     (2) reducer</p><p>​                    3. 核心方法:</p><p>​                                     (1) getState()</p><p>​                                     (2) dispatch(action)</p><p>​                                     (3) subscribe(listener)</p><p>​                    4. 具体编码:</p><p>​                                     (1) store.getState()</p><p>​                                     (2) store.dispatch({type:’INCREMENT’, number})</p><p>​                                     (3) store.subscribe(render)</p><h5 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware()"></a>applyMiddleware()</h5><p>​                   作用：应用上基于redux的中间件(插件库)</p><h5 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers()"></a>combineReducers()</h5><p>​                   作用：合并多个reducer函数</p><h4 id="redux异步编程"><a href="#redux异步编程" class="headerlink" title="redux异步编程"></a>redux异步编程</h4><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>​                   1. redux默认是不能进行异步处理的 </p><p>​                   2. 某些时候应用中需要在<strong>redux中执行异步任务</strong>(ajax, 定时器)</p><h5 id="使用异步中间件"><a href="#使用异步中间件" class="headerlink" title="使用异步中间件"></a>使用异步中间件</h5><p>​                   npm install –save redux-thunk</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯函数、高阶函数、函数柯里化</title>
      <link href="/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="纯函数、高阶函数、函数柯里化"><a href="#纯函数、高阶函数、函数柯里化" class="headerlink" title="纯函数、高阶函数、函数柯里化"></a>纯函数、高阶函数、函数柯里化</h4><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>​            1. 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</p><p>​            2. 必须遵守以下一些约束 </p><p>​                           (1) 不得改写参数数据</p><p>​                           (2) 不会产生任何副作用，例如网络请求，输入和输出设备</p><p>​                           (3) 不能调用Date.now()或者Math.random()等不纯的方法 </p><p>​            3. redux的reducer函数必须是一个纯函数</p><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>​            1. 理解: 一类特别的函数</p><p>​                    (1) 情况1: 参数是函数</p><p>​                    (2) 情况2: 返回是函数</p><p>​            2. 常见的高阶函数: </p><p>​                    (1) 定时器设置函数</p><p>​                    (2) 数组的forEach()/map()/filter()/reduce()/find()/bind()</p><p>​                    (3) promise</p><p>​                    (4) react-redux中的connect函数</p><p>​             3. 作用: 能实现更加动态, 更加可扩展的功能</p><h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><p>​            函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 </p><p>​          </p><pre class="line-numbers language-none"><code class="language-none">function sum(a)&#123;          return  (b)&#x3D;&gt;&#123;                  return  (c)&#x3D;&gt;&#123;                         return a+b+c                         &#125;                  &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux</title>
      <link href="/2022/01/16/react-redux/"/>
      <url>/2022/01/16/react-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​            1. 一个react插件库</p><p>​            2. 专门用来简化react应用中使用redux</p><h4 id="react-Redux将所有组件分成两大类"><a href="#react-Redux将所有组件分成两大类" class="headerlink" title="react-Redux将所有组件分成两大类"></a>react-Redux将所有组件分成两大类</h4><p>​            1. UI组件</p><p>​                  (1) 只负责 UI 的呈现，不带有任何业务逻辑</p><p>​                  (2) 通过props接收数据(一般数据和函数)</p><p>​                  (3) 不使用任何 Redux 的 API</p><p>​                  (4) 一般保存在components文件夹下</p><p>​            2. 容器组件</p><p>​                  (1) 负责管理数据和业务逻辑，不负责UI的呈现</p><p>​                  (2) 使用 Redux 的 API</p><p>​                  (3) 一般保存在containers文件夹下</p><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><p>​                 1. Provider：让所有组件都可以得到state数据</p><p>​                 2. connect：用于包装 UI 组件生成容器组件</p><p>​                 3. mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性</p><p>​                 4. mapDispatchToProps：将分发action的函数转换为UI组件的标签属性</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react路由</title>
      <link href="/2022/01/16/react%E8%B7%AF%E7%94%B1/"/>
      <url>/2022/01/16/react%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h4><p>​                1. 单页Web应用（single page web application，SPA）。</p><p>​                2. 整个应用只有<strong>一个完整的页面</strong>。</p><p>​                3. 点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</p><p>​                4. 数据都需要通过ajax请求获取, 并在前端异步展现。</p><h4 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h4><h5 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由?"></a>1.什么是路由?</h5><p>​                          (1). 一个路由就是一个映射关系(key:value)</p><p>​                          (2). key为路径, value可能是function或component</p><h5 id="2-路由分类"><a href="#2-路由分类" class="headerlink" title="2.路由分类"></a>2.路由分类</h5><h6 id="1-后端路由："><a href="#1-后端路由：" class="headerlink" title="(1). 后端路由："></a>(1). 后端路由：</h6><p>​                           (1) 理解： value是function, 用来处理客户端提交的请求。</p><p>​                           (2) 注册路由： router.get(path, function(req, res))</p><p>​                           (3) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p><h6 id="2-前端路由："><a href="#2-前端路由：" class="headerlink" title="(2). 前端路由："></a>(2). 前端路由：</h6><p>​                           (1) 浏览器端路由，value是component，用于展示页面内容。</p><p>​                           (2) 注册路由: &lt; Route path=”/test” component={Test} &gt;</p><p>​                           (3) 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p><h4 id="react-router-dom的理解"><a href="#react-router-dom的理解" class="headerlink" title="react-router-dom的理解"></a>react-router-dom的理解</h4><p>​                           (1). react的一个插件库。</p><p>​                           (2). 专门用来实现一个SPA应用。</p><p>​                           (3). 基于react的项目基本都会用到此库。</p><h4 id="react-router-dom相关API"><a href="#react-router-dom相关API" class="headerlink" title="react-router-dom相关API"></a><strong>react-router-dom相关API</strong></h4><h5 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h5><p>​                        1. &lt; BrowserRouter &gt;</p><p>​                        2. &lt; HashRouter &gt;</p><p>​                        3. &lt; Route &gt;</p><p>​                        4. &lt; Redirect &gt;</p><p>​                        5. &lt; Link &gt;</p><p>​                        6. &lt; NavLink &gt;</p><p>​                        7. &lt; Switch &gt;</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>​                        1. history对象</p><p>​                        2. match对象</p><p>​                        3. withRouter函数        </p><h4 id="基本路由使用"><a href="#基本路由使用" class="headerlink" title="基本路由使用"></a>基本路由使用</h4><p>​                       1. 下载 react-router-dom:  npm install –save react-router-dom</p><p>​                       2. 引入bootstrap.css: &lt; link rel=”stylesheet” href=”/css/bootstrap.css” &gt;</p><p>​                                (1).明确好界面中的导航区、展示区</p><p>​                                (2).导航区的a标签改为Link标签&lt; Link to=”/xxxxx” &gt;Demo&lt;/ Link &gt;</p><p>​                                (3).展示区写Route标签进行路径的匹配&lt; Route path=’/xxxx’ component={Demo}/ &gt;</p><p>​                                (4).&lt; App &gt;的最外侧包裹了一个&lt; BrowserRouter &gt;或&lt; HashRouter &gt;</p><h4 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h4><p>​                         1.写法不同：</p><p>​                                     一般组件：&lt; Demo/ &gt;</p><p>​                                    路由组件：&lt; Route path=”/demo” component={Demo}/ &gt;</p><p>​                          2.存放位置不同：</p><p>​                                            一般组件：components</p><p>​                                            路由组件：pages</p><p>​                         3.接收到的props不同：</p><p>​                                            一般组件：写组件标签时传递了什么，就能收到什么</p><p>​                                            路由组件：接收到三个固定的属性history、location、match</p><h4 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a><strong>NavLink与封装NavLink</strong></h4><p>​                              1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</p><h4 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a><strong>Switch的使用</strong></h4><p>​    1.通常情况下，path和component是一一对应的关系。</p><p>​    2.Switch可以提高路由匹配效率(单一匹配)。</p><h4 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a><strong>解决多级路径刷新页面样式丢失的问题</strong></h4><p>​     1.public/index.html 中 引入样式时不写 ./ 写 / （常用）</p><p>​        2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）</p><p>​        3.使用HashRouter</p><h4 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a><strong>路由的严格匹配与模糊匹配</strong></h4><p>​    1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</p><p>​        2.开启严格匹配：&lt; Route exact={true} path=”/about” component={About} &gt;</p><p>​        3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</p><h4 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a><strong>Redirect的使用</strong></h4><p> 1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由</p><h4 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a><strong>向路由组件传递参数</strong></h4><p> <strong>1.params参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=’/demo/test/tom/18’} &gt;详情&lt; /Link &gt;</p><p>​              注册路由(声明接收)：&lt; Route path=”/demo/test/:name/:age” component={Test}/ &gt;</p><p>​              接收参数：this.props.match.params</p><p>​        <strong>2.search参数</strong></p><p>​              路由链接(携带参数)：&lt;Link to=’/demo/test?name=tom&amp;age=18’}&gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.search</p><p>​              备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p><p>​       <strong>3.state参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=*{* **{**pathname:’/demo/test’,state:{name:’tom’,age:18}**}** *}* &gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.state</p><p>​              备注：刷新也可以保留住参数</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-ajax</title>
      <link href="/2022/01/16/react-ajax/"/>
      <url>/2022/01/16/react-ajax/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​     1. React本身只关注于界面, 并不包含发送ajax请求的代码</p><p>​     2. 前端应用需要通过ajax请求与后台进行交互(json数据)</p><p>​     3. react应用中需要集成第三方ajax库(或自己封装)</p><h3 id="常用的ajax请求库"><a href="#常用的ajax请求库" class="headerlink" title="常用的ajax请求库"></a>常用的ajax请求库</h3><p>​       1. jQuery: 比较重, 如果需要另外引入不建议使用</p><p>​       2. axios: 轻量级, 建议使用</p><p>​                 (1) 封装XmlHttpRequest对象的ajax</p><p>​                 (2) promise风格</p><p>​                 (3) 可以用在浏览器端和node服务器端</p><h3 id="消息订阅-发布机制"><a href="#消息订阅-发布机制" class="headerlink" title="消息订阅-发布机制"></a>消息订阅-发布机制</h3><p>​      1. 工具库: PubSubJS</p><p>​      2. 下载: npm install pubsub-js –save </p><p>​      3. 使用: </p><p>​              (1) import PubSub from ‘pubsub-js’ //引入</p><p>​              (2) PubSub.subscribe(‘delete’, function(data){ }); //订阅</p><p>​              (3) PubSub.publish(‘delete’, data) //发布消息</p><h3 id="扩展：Fetch"><a href="#扩展：Fetch" class="headerlink" title="扩展：Fetch"></a>扩展：Fetch</h3><h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>​            1. <a href="https://github.github.io/fetch/">https://github.github.io/fetch/</a></p><p>​            2. <a href="https://segmentfault.com/a/1190000003810652">https://segmentfault.com/a/1190000003810652</a></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>​              1. fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求</p><p>​              2. 老版本浏览器可能不支持</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架</title>
      <link href="/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h3><p>​            1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目</p><p>​                     (1). 包含了所有需要的配置（语法检查、jsx编译、devServer…）</p><p>​                     (2). 下载好了所有相关的依赖</p><p>​                     (3). 可以直接运行一个简单效果</p><p>​            2. react提供了一个用于创建react项目的脚手架库: create-react-app</p><p>​            3. 项目的整体技术架构为:  react + webpack + es6 + eslint</p><p>​            4. 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</p><h5 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h5><p>​                    <strong>第一步</strong>，全局安装：npm i -g create-react-app</p><p>​                    <strong>第二步</strong>，切换到想创项目的目录，使用命令：create-react-app hello-react</p><p>​                    <strong>第三步</strong>，进入项目文件夹：cd hello-react</p><p>​                    <strong>第四步</strong>，启动项目：npm start</p><h4 id="react脚手架项目结构"><a href="#react脚手架项目结构" class="headerlink" title="react脚手架项目结构"></a>react脚手架项目结构</h4><p>​            public —- 静态资源文件夹</p><p>​                            favicon.icon —— 网站页签图标</p><p>​                            <strong>index.html ——– 主页面</strong></p><p>​                            logo192.png ——- logo图</p><p>​                            logo512.png ——- logo图</p><p>​                            manifest.json —– 应用加壳的配置文件</p><p>​                            robots.txt ——– 爬虫协议文件</p><p>​            src —- 源码文件夹</p><p>​                           App.css ——– App组件的样式</p><p>​                           <strong>App.js ——— App组件</strong></p><p>​                           App.test.js —- 用于给App做测试</p><p>​            index.css —— 样式</p><p>​                            <strong>index.js —— 入口文件</strong></p><p>​                            logo.svg ——- logo图</p><p>​                            reportWebVitals.js — 页面性能分析文件(需要web-vitals库的支持)</p><p>​                            setupTests.js</p><h4 id="功能界面的组件化编码流程（通用）"><a href="#功能界面的组件化编码流程（通用）" class="headerlink" title="功能界面的组件化编码流程（通用）"></a>功能界面的组件化编码流程（通用）</h4><p>​     1. 拆分组件: 拆分界面,抽取组件</p><p>​     2. 实现静态组件: 使用组件实现静态页面效果</p><p>​     3. 实现动态组件</p><p>​                   (1) 动态显示初始化数据</p><p>​                              ① 数据类型</p><p>​                              ② 数据名称</p><p>​                              ③ 保存在哪个组件?</p><p>​                   (2)交互(从绑定事件监听开始)</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-jsx</title>
      <link href="/2022/01/14/react-jsx/"/>
      <url>/2022/01/14/react-jsx/</url>
      
        <content type="html"><![CDATA[<ol><li><p>全称:  JavaScript XML</p></li><li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是 <strong>React.createElement(component,props,…children)</strong> 方法的语法糖</p></li><li><p>作用: 用来简化创建虚拟DOM </p></li></ol><p>​         (1) 写法：<strong>var  ele = &lt; h3 &gt; hello,jsx!&lt; /h3 &gt;</strong></p><p>​         (2) 注意1：它不是字符串, 也不是HTML/XML标签</p><p>​         (3) 注意2：它最终产生的就是一个JS对象</p><ol start="4"><li><p>标签名任意: HTML标签或其它标签</p></li><li><p>标签属性任意: HTML标签属性或其它</p></li><li><p>基本语法规则</p><p>(1). 遇到 &lt;开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</p><p>(2).遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含</p><p>(3).定义虚拟DOM时，不要写引号</p><p>(4).样式的类名指定不要用class，要用className</p><p>(5).内联样式，要用style= <strong>{</strong>{key:value}<strong>}</strong> 的形式去写</p><p>(6).只有一个根标签</p><p>(7).标签必须闭合</p><p>(8).标签首字母</p><p>​         ①.若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错</p><p>​         ②.若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中key的作用</title>
      <link href="/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题:"></a>经典面试题:</h3><p>   <em>一. react/vue中的key有什么作用？（key的内部原理是什么？）</em></p><p>   <em>二. 为什么遍历列表时，key最好不要用index?</em></p><p>​    <strong>1. 虚拟DOM中key的作用：</strong></p><p>​      （1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p><p>​      （2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>​                 ①. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>​                         a.若虚拟DOM中内容没变, 直接使用之前的真实DOM</p><p>​                         b.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>​                 ②. 旧虚拟DOM中未找到与新虚拟DOM相同的key根据数据创建新的真实DOM，随后渲染到到页面</p><p>​    <strong>2.用index作为key可能会引发的问题：</strong></p><p>​       (1). 若对数据进行：逆序添加、逆序删除等破坏顺序操作,会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p><p>​       (2). 如果结构中还包含输入类的DOM,会产生错误DOM更新 ==&gt; 界面有问题。</p><p>​       (3). 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><p>​          </p><p>​    <strong>3. 开发中如何选择key:</strong></p><p>​      (1).最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p><p>​      (2).如果确定只是简单的展示数据，用index也是可以的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react生命周期</title>
      <link href="/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>​        1. 组件从创建到死亡它会经历一些特定的阶段。</p><p>​        2. React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</p><p>​        3. 我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</p><h3 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h3><p><img src="/2022/01/14/react生命周期/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>生命周期的三个阶段</p><p>​           <strong>1.初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p><p>​                            (1). constructor()</p><p>​                            (2).getDerivedStateFromProps</p><p>​                            (3). render()</p><p>​                            (4). componentDidMount()</p><p>​           <strong>2.更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p><p>​                            (1).getDerivedStateFromProps</p><p>​                            (2). shouldComponentUpdate()</p><p>​                            (3). render()</p><p>​                            (4). getSnapshotBeforeUpdate</p><p>​                            (5). componentDidUpdate()</p><p>​           <strong>3.卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发</p><p>​                            (1). componentWillUnmount()</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件的三大核心属性</title>
      <link href="/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​                        1. state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</p><p>​                        2. 组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</p><h4 id="强烈注意"><a href="#强烈注意" class="headerlink" title="强烈注意"></a>强烈注意</h4><p>​                        1. 组件中render方法中的this为组件实例对象</p><p>​                        2. 组件自定义的方法中this为undefined，如何解决？</p><p>​                                 ① 强制绑定this: 通过函数对象的bind()</p><p>​                                 ② 箭头函数</p><p>​                        3. 状态数据，不能直接修改或更新</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>​                       1. 每个组件对象都会有props(properties的简写)属性</p><p>​                       2. 组件标签的所有属性都保存在props中</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​                       1. 通过标签属性从组件外向组件内传递变化的数据</p><p>​                       2. 注意: 组件内部不要修改props数据</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>​                       1. 内部读取某个属性值</p><p>​                                <strong>this.props.name</strong></p><p>​                       2. 对props中的属性值进行类型限制和必要性限制</p><p>​                                使用prop-types库进限制（需要引入prop-types库）</p><p>​                                        <strong>Person.propTypes = {</strong></p><p>​                                                <strong>name: PropTypes.string.isRequired,</strong></p><p>​                                                <strong>age: PropTypes.number</strong></p><p>​                                        <strong>}</strong></p><p>​                       3. 扩展属性: 将对象的所有属性通过props传递</p><p>​                                <strong>&lt;Person {…person}/&gt;</strong></p><p>​                       4.默认属性值</p><p>​                                   <strong>Person.defaultProps = {</strong></p><p>​                                            <strong>age: 18,</strong></p><p>​                                            <strong>sex: “男”</strong></p><p>​                                    <strong>}</strong></p><p>​                       5.组件类的构造函数</p><p>​                                   <strong>constructor(props){</strong></p><p>​                                         <strong>super(props)</strong>    </p><p>​                                    <strong>}</strong></p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><p>​                      组件内的标签可以定义ref属性来标识自己</p><h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>​                    1.字符串形式的ref         </p><p>​                                    <strong>&lt; input ref=”input1”/ &gt;</strong>                </p><p>​                    2.回调形式的ref</p><p>​                                    <strong>&lt;input ref={(c)=&gt;{this.input1 = c}}/&gt;</strong>        </p><p>​                    3.create创建ref容器</p><p>​                                    <strong>myRef = React.createRef()</strong></p><p>​                                    <strong>&lt; input ref={this.myRef}/ &gt;</strong>        </p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>​        1. 通过onXxx属性指定事件处理函数(注意大小写)</p><p>​                （1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</p><p>​                （2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</p><p>​       2. 通过event.target得到发生事件的DOM元素对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块与组件、模块化与组件化的理解</title>
      <link href="/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    1. 理解：向外提供特定功能的js程序, 一般就是一个js文件</p><p>​    2. 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。</p><p>​    3. 作用：复用js, 简化js的编写, 提高js运行效率</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>​    1. 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)</p><p>​    2. 为什么要用组件： 一个界面的功能更复杂</p><p>​    3. 作用：复用编码, 简化项目编码, 提高运行效率</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    当应用的js都以模块来编写的, 这个应用就是一个模块化的应用</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>​    当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react介绍描述</title>
      <link href="/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/"/>
      <url>/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍描述"><a href="#介绍描述" class="headerlink" title="介绍描述"></a>介绍描述</h3><ol><li><p>用于动态构建用户界面的 JavaScript 库(只关注于视图)</p></li><li><p>由Facebook开源</p></li></ol><h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol><li><p>声明式编码</p></li><li><p>组件化编码</p></li><li><p>React Native 编写原生应用</p></li><li><p>高效（优秀的Diffing算法）</p></li></ol><h3 id="React高效的原因"><a href="#React高效的原因" class="headerlink" title="React高效的原因"></a>React高效的原因</h3><ol><li><p>使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。</p></li><li><p>DOM Diffing算法, 最小化页面重绘。</p></li></ol><h3 id="虚拟DOM与真实DOM"><a href="#虚拟DOM与真实DOM" class="headerlink" title="虚拟DOM与真实DOM"></a>虚拟DOM与真实DOM</h3><ol><li><p>React提供了一些API来创建一种 “特别” 的一般js对象</p><p><strong>const    VDOM = React.createElement(‘xx’,{id:’xx’},’xx’)</strong></p><p>上面创建的就是一个简单的虚拟DOM对象</p></li><li><p>虚拟DOM对象最终都会被React转换为真实的DOM</p></li><li><p>我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
