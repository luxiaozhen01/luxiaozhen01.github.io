<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue2</title>
      <link href="/2022/04/08/vue2/"/>
      <url>/2022/04/08/vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h3 id="初始Vue"><a href="#初始Vue" class="headerlink" title="初始Vue"></a>初始Vue</h3><p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p><p>2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p><p>3.root容器里的代码被称为【Vue模板】；</p><p>4.Vue实例和容器是一一对应的；</p><p>5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p><p>6.中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p><p>7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p><p><span style="color:red;"><strong>注意区分：js表达式 和 js代码(语句)</strong></span></p><p>​       1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：</p><p>​            (1). a</p><p>​            (2). a+b</p><p>​            (3). demo(1)</p><p>​            (4). x === y ? ‘a’ : ‘b’</p><p>2.js代码(语句)</p><p>​            (1). if(){}</p><p>​            (2). for(){}</p><h3 id="Vue的模板语法"><a href="#Vue的模板语法" class="headerlink" title="Vue的模板语法"></a><strong>Vue的模板语法</strong></h3><p><em><strong>Vue模板语法有2大类：</strong></em></p><p>​     <strong>1.插值语法：</strong></p><p>​       功能：用于解析标签体内容。</p><p>​       写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p><p>​     <strong>2.指令语法：</strong></p><p>​       功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p><p>​       举例：v-bind:href=”xxx” 或  简写为 :href=”xxx”，xxx同样要写js表达式,且可以直接读取到data中的所有属性。</p><p>​       备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a><strong>数据绑定</strong></h3><p><strong>Vue中有2种数据绑定的方式：</strong></p><p>​       1.单向绑定(v-bind)：数据只能从data流向页面。</p><p>​       2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p><p>​     备注：</p><p>​       1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>​       2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p><h3 id="data与el的两种写法"><a href="#data与el的两种写法" class="headerlink" title="data与el的两种写法"></a><strong>data与el的两种写法</strong></h3><p><em><strong>data与el的2种写法</strong></em></p><p>​      <strong>1.el有2种写法</strong></p><p>​        (1).new Vue时候配置el属性。</p><p>​        (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p><p>​      <strong>2.data有2种写法</strong></p><p>​        (1).对象式</p><p>​        (2).函数式</p><p>​        如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p><p>​      <strong>3.一个重要的原则：</strong></p><p>​        由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p><h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a><strong>MVVM模型</strong></h3><p>​        1. M：模型(Model) ：data中的数据</p><p>​        2. V：视图(View) ：模板代码</p><p>​        3. VM：视图模型(ViewModel)：Vue实例</p><p>​     观察发现：</p><p>​        1.data中所有的属性，最后都出现在了vm身上。</p><p>​        2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a><strong>数据代理</strong></h3><p><strong>1.Vue中的数据代理：</strong>通过vm对象来代理data对象中属性的操作（读/写）</p><p><strong>2.Vue中数据代理的好处：</strong>更加方便的操作data中的数据</p><p><strong>3.基本原理：</strong></p><p>​         通过Object.defineProperty()把data对象中所有属性添加到vm上。</p><p>​         为每一个添加到vm上的属性，都指定一个getter/setter。</p><p>​         在getter/setter内部去操作（读/写）data中对应的属性。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a><strong>事件处理</strong></h3><p><strong>事件的基本使用：</strong></p><p>​      1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p><p>​      2.事件的回调需要配置在methods对象中，最终会在vm上；</p><p>​      3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p><p>​      4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p><p>​      5.@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参；</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a><strong>事件修饰符</strong></h3><p>​      1.prevent：阻止默认事件（常用）；（js原生阻止默认事件event.preventDefault）</p><p>​      2.stop：阻止事件冒泡（常用）；(js原生阻止事件冒泡event.stopPropagation)</p><p>​      3.once：事件只触发一次（常用）；</p><p>​      4.capture：使用事件的捕获模式,加在外部事件上；</p><p>​      5.self：只有event.target是当前操作的元素时才触发事件；</p><p>​      6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p><p>​       7.事件修饰符可以连续写  @click.prevent.stop= “demo”</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a><strong>键盘事件</strong></h3><p>1.Vue中常用的按键别名：</p><p>​         回车 =&gt; enter</p><p>​         删除 =&gt; delete (捕获“删除”和“退格”键)</p><p>​         退出 =&gt; esc</p><p>​         空格 =&gt; space</p><p>​         换行 =&gt; tab (特殊，必须配合keydown去使用)</p><p>​         上 =&gt; up</p><p>​         下 =&gt; down</p><p>​         左 =&gt; left</p><p>​         右 =&gt; right</p><p>   2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p><p>   3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p><p>​       (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p><p>​       (2).配合keydown使用：正常触发事件。</p><p> 4.也可以使用keyCode去指定具体的按键（不推荐）</p><p>5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p><p>6.可以组合指定比如：@keyup.ctrl.y 按下ctrl+y才会触发</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><strong>计算属性</strong></h3><p>​     <strong>1.定义：</strong>要用的属性不存在，要通过已有属性计算得来。</p><p>​     <strong>2.原理：</strong>底层借助了Objcet.defineproperty方法提供的getter和setter。</p><p>​     <strong>3.get函数什么时候执行？</strong></p><p>​         (1).初次读取时会执行一次。</p><p>​         (2).当依赖的数据发生改变时会被再次调用。</p><p>​     <strong>4.优势：</strong>与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>​     <strong>5.备注：</strong></p><p>​      (1).计算属性最终会出现在vm上，直接读取使用即可。</p><p>​       (2).如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p><h3 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a><strong>监视属性</strong></h3><p><strong>监视属性watch：</strong></p><p>​     1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p><p>​     2.监视的属性必须存在，才能进行监视！！</p><p>​     3.监视的两种写法：</p><p>​         (1).new Vue时传入watch配置</p><p>​         (2).通过vm.$watch监视</p><p><strong>深度监视：</strong></p><p>​      (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p><p>​      (2).配置deep:true可以监测对象内部值改变（多层）。</p><p> <strong>备注：</strong></p><p>​      (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p><p>​      (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p><p> <strong>配置项：</strong></p><p>​       immediate     让监视属性初始化时调用一下</p><p>​       deep  开启深度监视</p><h3 id="computed与watch之间的区别"><a href="#computed与watch之间的区别" class="headerlink" title="computed与watch之间的区别"></a><strong>computed与watch之间的区别</strong></h3><p><strong>computed和watch之间的区别：</strong></p><p>​       1.computed能完成的功能，watch都可以完成。</p><p>​        2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p><p><strong>两个重要的小原则：</strong></p><p>​       1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p><p>​       2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p><p>​    </p><h3 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a><strong>绑定样式</strong></h3><p>​      <strong>1. class样式</strong></p><p>​        写法:class=”xxx” xxx可以是字符串、对象、数组。</p><p>​            字符串写法适用于：类名不确定，要动态获取。</p><p>​            对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p><p>​            数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><p>​      <strong>2. style样式</strong></p><p>​        :style=”{fontSize: xxx}”其中xxx是动态值。</p><p>​        :style=”[a,b]”其中a、b是样式对象。</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a><strong>条件渲染</strong></h3><p>​       <strong>1.v-if</strong></p><p>​         写法：</p><p>​          (1).v-if=”表达式” </p><p>​          (2).v-else-if=”表达式”</p><p>​          (3).v-else=”表达式”</p><p>​         适用于：切换频率较低的场景。</p><p>​         特点：不展示的DOM元素直接被移除。</p><p>​         注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><p>​       <strong>2.v-show</strong></p><p>​         写法：v-show=”表达式”</p><p>​         适用于：切换频率较高的场景。</p><p>​         特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><p>​                </p><p>​       <strong>3.备注：</strong>使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p><p>​            &lt; template &gt;只能和v-if配合使用</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a><strong>列表渲染</strong></h3><p><strong>v-for指令:</strong></p><p>​      1.用于展示列表数据</p><p>​      2.语法：v-for=”(item, index) in xxx” :key=”yyy”</p><p>​      3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p><h3 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a><strong>Vue监视数据原理</strong></h3><ol><li><p>vue会监视data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？</p></li></ol><p>​        通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>​         (1).对象中后追加的属性，Vue默认不做响应式处理</p><p>​         (2).如需给后添加的属性做响应式，请使用如下API：</p><p>​              Vue.set(target，propertyName/index，value) 或 </p><p>​              vm.$set(target，propertyName/index，value)</p><ol start="3"><li>如何监测数组中的数据？</li></ol><p>​        通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>​         (1).调用原生对应的方法对数组进行更新。</p><p>​         (2).重新解析模板，进而更新页面。</p><p>   4.在Vue修改数组中的某个元素一定要用如下方法：</p><p>​        (1).使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​        (2).Vue.set() 或 vm.$set()</p><p>​    <span style="color:red"> 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</span></p><h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a><strong>收集表单数据</strong></h3><p>收集表单数据：</p><p>​    若：&lt; input type=”text”/ &gt;，则v-model收集的是value值，用户输入的就是value值。</p><p>​    若：&lt; input type=”radio”/ &gt;，则v-model收集的是value值，且要给标签配置value值。</p><p>​    若：&lt; input type=”checkbox”/ &gt;</p><p>​       1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​       2.配置input的value属性:</p><p>​         (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​         (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p><p>​    备注：v-model的三个修饰符：</p><p>​         lazy：失去焦点再收集数据</p><p>​         number：输入字符串转为有效的数字</p><p>​         trim：输入首尾空格过滤</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><strong>过滤器</strong></h3><p> <strong>定义：</strong>对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>  <strong>语法：</strong></p><p>​      1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p><p>​      2.使用过滤器：{ { xxx | 过滤器名} }  或  v-bind:属性 = “xxx | 过滤器名”</p><p>​     <strong>备注：</strong></p><p>​       1.过滤器也可以接收额外参数、多个过滤器也可以串联</p><p>​      2.并没有改变原本的数据, 是产生新的对应的数据</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a><strong>内置指令</strong></h3><p>  <strong>v-bind</strong> : 单向绑定解析表达式, 可简写为 :xxx</p><p>​        <strong>v-model</strong> : 双向数据绑定</p><p>​        <strong>v-for</strong>  : 遍历数组/对象/字符串</p><p>​        <strong>v-on</strong>   : 绑定事件监听, 可简写为@</p><p>​        <strong>v-if</strong>     : 条件渲染（动态控制节点是否存存在）</p><p>​        <strong>v-else</strong>  : 条件渲染（动态控制节点是否存存在）</p><p>​        <strong>v-show</strong>  : 条件渲染 (动态控制节点是否展示)</p><p>​       <strong>v-text</strong>指令：</p><p>​          1.作用：向其所在的节点中渲染文本内容。</p><p>​          2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p><p>​        <strong>v-html</strong>指令：</p><p>​          1.作用：向指定节点中渲染包含html结构的内容。</p><p>​          2.与插值语法的区别：</p><p>​            (1).v-html会替换掉节点中所有的内容，则不会。</p><p>​            (2).v-html可以识别html结构。</p><p>​         <span style="color:red"> 3.严重注意：v-html有安全性问题！！！！</span></p><p>​            (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p><p>​            (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p><p><strong>v-cloak</strong>指令（没有值）：</p><p>​          1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p><p>​          2.使用css配合v-cloak可以解决网速慢时页面展示出的问题。</p><p><strong>v-once</strong>指令：</p><p>​          1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p><p>​          2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><p><strong>v-pre</strong>指令：</p><p>​          1.跳过其所在节点的编译过程。</p><p>​          2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><strong>自定义指令</strong></h3><p> <strong>一、定义语法：</strong></p><p>​     (1).局部指令：</p><p>​       </p><pre class="line-numbers language-none"><code class="language-none">new Vue(&#123;directives:&#123;指令名: 配置对象&#125;&#125;)或new Vue(&#123;directives:&#123;指令名: 回调函数&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     (2).全局指令：</p><p>​       Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)</p><p><strong>二、配置对象中常用的3个回调：</strong></p><p>​     (1).bind：指令与元素成功绑定时调用。</p><p>​     (2).inserted：指令所在元素被插入页面时调用。</p><p>​     (3).update：指令所在模板结构被重新解析时调用。</p><p>​     </p><p>​     <strong>三、备注：</strong></p><p>​      1.指令定义时不加v-，但使用时要加v-；</p><p>​      2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p><img src="2022/04/08/vue2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期图"></p><p> 1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p><p>​     2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p><p>​      3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>​     4.生命周期函数中的this指向是vm 或 组件实例对象。</p><p>常用的生命周期钩子：</p><p>​     1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p><p>​     2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p><p>   关于销毁Vue实例</p><p>​     1.销毁后借助Vue开发者工具看不到任何信息。</p><p>​     2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p><p>​     3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a><strong>组件</strong></h3><p><em><strong>Vue中使用组件的三大步骤：</strong></em></p><p>​        一、定义组件(创建组件)</p><p>​        二、注册组件</p><p>​        三、使用组件(写组件标签)</p><p>​      <strong>一、如何定义一个组件？</strong></p><p>​         使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；区别如下：</p><p>​          1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</p><p>​          2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</p><p>​          备注：使用template可以配置组件结构。</p><p>​       <strong>二、如何注册组件？</strong></p><p>​          1.局部注册：靠new Vue的时候传入components选项</p><p>​          2.全局注册：靠Vue.component(‘组件名’,组件)</p><p>​       三、编写组件标签：  &lt; school &gt;&lt; /school &gt;</p><p><span style="color:red">关于VueComponent：</span></p><p>​      1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p><p>​      2.我们只需要写&lt; school/ &gt;或&lt; school &gt;&lt; /school &gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。</p><p>​    3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</p><p>​      4.关于this指向：</p><p>​        (1).组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</p><p>​        (2).new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p><p>5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。</p><p><strong>重要内置关系</strong>：</p><p>   1.一个重要的内置关系：VueComponent.prototype. _ _ proto _ _ === Vue.prototype</p><p>​     2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2022/03/21/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/03/21/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table>        <tr>                      <td>git --version</td>              <td>查看git版本</td>        </tr>         <tr>            <td>git init</td>            <td>初始化仓库</td>        </tr>        <tr>            <td>git config --global user.name xxx </td>            <td>设置用户签名</td>        </tr>        <tr>            <td>git config --global user.email xxx</td>            <td>设置用户邮箱</td>        </tr>        <tr>            <td>git status</td>            <td>查看文件状态</td>        </tr>        <tr>            <td>git add  <filename></filename></td>            <td>将文件添加到暂存区</td>        </tr>        <tr>            <td>ll</td>            <td>linux命令，查看工作区文件</td>        </tr>        <tr>            <td>clear</td>            <td>清空页面</td>        </tr>        <tr>            <td>git rm --cached  <filename></filename></td>            <td>删除暂存区文件</td>        </tr>        <tr>            <td>git commit -m “日志备注”  <filename></filename></td>            <td>将文件提交到本地库</td>        </tr>        <tr>            <td>git commit -a -m “备注” </td>            <td>-a可以将所有被修改或者已删除的且已经被git管理的文档提交到仓库中，注意-a不会造成新的文件被提交，只能修改</td>        </tr>        <tr>            <td>git reflog  / git log</td>            <td>查看版本信息</td>        </tr>        <tr>            <td>cat  <filename></filename></td>            <td>查看文件内容</td>        </tr>        <tr>            <td>vim  <filename></filename></td>            <td>修改文件内容 :wp 保存 :q!不保存退出 yy复制 p 粘贴 a进入编辑模式 Esc进入操作模式</td>        </tr>        <tr>            <td>git reset  --hard  <版本号> </版本号></td>            <td>版本穿梭</td>        </tr>        <tr>            <td>git branch -v </td>            <td>查看分支（*代表当前所在分支）</td>        </tr>        <tr>            <td>git branch  <分支名></分支名></td>            <td>创建分支</td>        </tr>        <tr>            <td>git branch -d  <分支名></分支名></td>            <td>删除一个分支</td>        </tr>        <tr>            <td>git checkout  <分支名></分支名></td>            <td>切换分支</td>        </tr>        <tr>            <td>git merge  <分支名></分支名></td>            <td>把指定的分支合并到当前分支上</td>        </tr>        <tr>            <td>冲突合并</td>            <td>两个分支修改同一个文件的同一个地方合并的时候会发生合并冲突解决办法：手动合并，vim打开文件将需要修改的地方手动修改一下，然后保存退出，再次添加暂存区，再次提交本库注意提交本地库时不要再加文件名称了（git commit -m “日志备注”）</td>        </tr>        <tr>            <td>git remote add <别名>  <远程仓库地址></远程仓库地址></别名></td>            <td>给远程仓库起别名</td>        </tr>        <tr>            <td>git remote -v</td>            <td>查看当前所有远程仓库地址的别名</td>        </tr>        <tr>            <td>git push <远程库地址或别名> <分支名></分支名></远程库地址或别名></td>            <td>往远程仓库推送</td>        </tr>        <tr>            <td>git pull  <远程库地址或别名> <分支名></分支名></远程库地址或别名></td>            <td>拉取远程仓库代码</td>        </tr>        <tr>            <td>git clone  <远程仓库地址></远程仓库地址></td>            <td>1、初始化本地仓库2、拉取代码创建别名（之前的别名git自动用origin代替）</td>        </tr>    </table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react扩展</title>
      <link href="/2022/01/27/react%E6%89%A9%E5%B1%95/"/>
      <url>/2022/01/27/react%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h3><h4 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h4><p>(1). setState(stateChange, [callback])——对象式的setState<br>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)<br>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</p><p>(2). setState(updater, [callback])——函数式的setState<br>        1.updater为返回stateChange对象的函数。<br>        2.updater可以接收到state和props。<br>        4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</p><p>总结:<br>        1.对象式的setState是函数式的setState的简写方式(语法糖)<br>        2.使用原则：<br>                (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式<br>                (2).如果新状态依赖于原状态 ===&gt; 使用函数方式<br>                (3).如果需要在setState()执行后获取最新的状态数据,<br>                    要在第二个callback函数中读取</p><h3 id="2-lazyLoad"><a href="#2-lazyLoad" class="headerlink" title="2. lazyLoad"></a>2. lazyLoad</h3><h4 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h4><p>1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包<br>const Login = lazy(()=&gt;import(‘@/pages/Login’))</p><p>2.通过&lt; Suspense &gt;指定在加载得到路由打包文件前显示一个自定义loading界面</p><pre class="line-numbers language-none"><code class="language-none">&lt;Suspense fallback&#x3D;&#123;&lt; h1 &gt;loading.....&lt;&#x2F; h1 &gt;&#125;&gt;    &lt; Switch &gt;        &lt; Route path&#x3D;&quot;&#x2F;xxx&quot; component&#x3D;&#123;Xxxx&#125;&#x2F; &gt;        &lt;Redirect to&#x3D;&quot;&#x2F;login&quot;&#x2F; &gt;    &lt; &#x2F;Switch &gt;&lt; &#x2F;Suspense &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h3><h4 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook/Hooks是什么?"></a>1. React Hook/Hooks是什么?</h4><p>(1). Hook是React 16.8.0版本增加的新特性/新语法<br>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</p><h4 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h4><p>(1). State Hook: React.useState()<br>(2). Effect Hook: React.useEffect()<br>(3). Ref Hook: React.useRef()</p><h4 id="3-State-Hook"><a href="#3-State-Hook" class="headerlink" title="3. State Hook"></a>3. State Hook</h4><p>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作<br>(2). 语法: const [xxx, setXxx] = React.useState(initValue)<br>(3). useState()说明:<br>        参数: 第一次初始化指定的值在内部作缓存<br>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数<br>(4). setXxx()2种写法:<br>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值<br>        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</p><h4 id="4-Effect-Hook"><a href="#4-Effect-Hook" class="headerlink" title="4. Effect Hook"></a>4. Effect Hook</h4><p>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)<br>(2). React中的副作用操作:<br>        发ajax请求数据获取<br>        设置订阅 / 启动定时器<br>        手动更改真实DOM<br>(3). 语法和说明: </p><pre class="line-numbers language-none"><code class="language-none">useEffect(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 在此可以执行任何带副作用操作    return () &#x3D;&gt; &#123; &#x2F;&#x2F; 在组件卸载前执行      &#x2F;&#x2F; 在此做一些收尾工作, 比如清除定时器&#x2F;取消订阅等    &#125;  &#125;, [stateValue]) &#x2F;&#x2F; 如果指定的是[], 回调函数只会在第一次render()后执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4). 可以把 useEffect Hook 看做如下三个函数的组合<br>        componentDidMount()<br>        componentDidUpdate()<br>        componentWillUnmount() </p><h4 id="5-Ref-Hook"><a href="#5-Ref-Hook" class="headerlink" title="5. Ref Hook"></a>5. Ref Hook</h4><p>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据<br>(2). 语法: const refContainer = useRef()<br>(3). 作用:保存标签对象,功能与React.createRef()一样</p><h3 id="4-Context"><a href="#4-Context" class="headerlink" title="4. Context"></a>4. Context</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">1. 创建Context容器对象：   const XxxContext &#x3D; React.createContext()  2. 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：   &lt;xxxContext.Provider value&#x3D;&#123;数据&#125;&gt;   子组件    &lt;&#x2F;xxxContext.Provider&gt;3. 后代组件读取数据：   &#x2F;&#x2F;第一种方式:仅适用于类组件      static contextType &#x3D; xxxContext  &#x2F;&#x2F; 声明接收context     this.context &#x2F;&#x2F; 读取context中的value数据   &#x2F;&#x2F;第二种方式: 函数组件与类组件都可以     &lt;xxxContext.Consumer&gt;       &#123;         value &#x3D;&gt; ( &#x2F;&#x2F; value就是context中的value数据           要显示的内容         )       &#125;     &lt;&#x2F;xxxContext.Consumer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在应用开发中一般不用context, 一般都用它的封装react插件</p><h3 id="5-组件优化"><a href="#5-组件优化" class="headerlink" title="5. 组件优化"></a>5. 组件优化</h3><h4 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h4><ol><li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render() ==&gt; 效率低</p></li><li><p>只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==&gt; 效率低</p></li></ol><h4 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h4><p>只有当组件的state或props数据发生改变时才重新render()</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>Component中的shouldComponentUpdate()总是返回true</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>办法1:<br>    重写shouldComponentUpdate()方法<br>    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false<br>办法2:<br>    使用PureComponent<br>    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true<br>    注意:<br>        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false<br>        不要直接修改state数据, 而是要产生新数据<br>项目中一般使用PureComponent来优化</p><h3 id="6-render-props"><a href="#6-render-props" class="headerlink" title="6. render props"></a>6. render props</h3><h4 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h4><p>Vue中:<br>    使用slot技术, 也就是通过组件标签体传入结构  &lt; A &gt;&lt; B/&gt;&lt; /A&gt;<br>React中:<br>    使用children props: 通过组件标签体传入结构<br>    使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性</p><h4 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h4><pre class="line-numbers language-none"><code class="language-none">&lt;A&gt;  &lt;B&gt;xxxx&lt;&#x2F;B&gt;&lt;&#x2F;A&gt;&#123;this.props.children&#125;问题: 如果B组件需要A组件内的数据, &#x3D;&#x3D;&gt; 做不到 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h4><p>&lt;A render={(data) =&gt; &lt; C data={data}&gt;&lt; /C &gt;}&gt;&lt; /A&gt;<br>A组件: {this.props.render(内部state数据)}<br>C组件: 读取A组件传入的数据显示 {this.props.data} </p><h3 id="7-错误边界"><a href="#7-错误边界" class="headerlink" title="7. 错误边界"></a>7. 错误边界</h3><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p><strong>getDerivedStateFromError配合componentDidCatch</strong></p><p>生命周期函数，一旦后台组件报错，就会触发</p><pre class="line-numbers language-none"><code class="language-none">static getDerivedStateFromError(error) &#123;    console.log(error);    &#x2F;&#x2F;在render之前触发    &#x2F;&#x2F;返回新的state    return &#123;        hasError: true,    &#125;;&#125;componentDidCatch(error, info) &#123;     &#x2F;&#x2F;统计页面的错误。发送请求发送到后台去    console.log(error, info);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-组件通信方式总结"><a href="#8-组件通信方式总结" class="headerlink" title="8. 组件通信方式总结"></a>8. 组件通信方式总结</h3><h4 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h4><ul><li>父子组件</li><li>兄弟组件（非嵌套组件）</li><li>祖孙组件（跨级组件）</li></ul><h4 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h4><h5 id="1-props："><a href="#1-props：" class="headerlink" title="1.props："></a>1.props：</h5><p>​    (1).children props<br>​    (2).render props</p><h5 id="2-消息订阅-发布："><a href="#2-消息订阅-发布：" class="headerlink" title="2.消息订阅-发布："></a>2.消息订阅-发布：</h5><p>​    pubs-sub、event等等</p><h5 id="3-集中式管理："><a href="#3-集中式管理：" class="headerlink" title="3.集中式管理："></a>3.集中式管理：</h5><p>​    redux、dva等等</p><h5 id="4-conText"><a href="#4-conText" class="headerlink" title="4.conText:"></a>4.conText:</h5><p>​    生产者-消费者模式</p><h4 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h4><p>​    父子组件：props<br>​    兄弟组件：消息订阅-发布、集中式管理<br>​    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux</title>
      <link href="/2022/01/18/redux/"/>
      <url>/2022/01/18/redux/</url>
      
        <content type="html"><![CDATA[<h4 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h4><h5 id="redux是什么"><a href="#redux是什么" class="headerlink" title="redux是什么"></a>redux是什么</h5><p>​                        1. redux是一个专门用于做<strong>状态管理</strong>的JS库(不是react插件库)。</p><p>​                        2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p><p>​                        3. 作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</p><h5 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h5><p>​                        1. 某个组件的状态，需要让其他组件可以随时拿到（共享）。</p><p>​                        2. 一个组件需要改变另一个组件的状态（通信）。</p><p>​                        3. 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</p><h5 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h5><p>​                    <img src="/2022/01/18/redux/redux.png" alt="redux"></p><h4 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h4><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><p>​                1. 动作的对象</p><p>​                2. 包含2个属性</p><p>​                        type：标识属性, 值为字符串, 唯一, 必要属性</p><p>​                        data：数据属性, 值类型任意, 可选属性</p><p>​                3. 例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</p><h5 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h5><p>​                1. 用于初始化状态、加工状态。</p><p>​                2. 加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</p><h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><p>​                1. 将state、action、reducer联系在一起的对象</p><p>​                2. 如何得到此对象?</p><p>​                       (1) import {createStore} from ‘redux’</p><p>​                       (2) import reducer from ‘./reducers’</p><p>​                       (3) const store = createStore(reducer)</p><p>​                3. 此对象的功能?</p><p>​                       (1) getState(): 得到state</p><p>​                       (2) dispatch(action): 分发action, 触发reducer调用, 产生新的state</p><p>​                       (3) subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p><h4 id="redux的核心API"><a href="#redux的核心API" class="headerlink" title="redux的核心API"></a>redux的核心API</h4><h5 id="createstore"><a href="#createstore" class="headerlink" title="createstore()"></a>createstore()</h5><p>​                   作用：创建包含指定reducer的store对象</p><h5 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h5><p>​                    1. 作用: redux库最核心的管理对象</p><p>​                    2. 它内部维护着:</p><p>​                                     (1) state</p><p>​                                     (2) reducer</p><p>​                    3. 核心方法:</p><p>​                                     (1) getState()</p><p>​                                     (2) dispatch(action)</p><p>​                                     (3) subscribe(listener)</p><p>​                    4. 具体编码:</p><p>​                                     (1) store.getState()</p><p>​                                     (2) store.dispatch({type:’INCREMENT’, number})</p><p>​                                     (3) store.subscribe(render)</p><h5 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware()"></a>applyMiddleware()</h5><p>​                   作用：应用上基于redux的中间件(插件库)</p><h5 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers()"></a>combineReducers()</h5><p>​                   作用：合并多个reducer函数</p><h4 id="redux异步编程"><a href="#redux异步编程" class="headerlink" title="redux异步编程"></a>redux异步编程</h4><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>​                   1. redux默认是不能进行异步处理的 </p><p>​                   2. 某些时候应用中需要在<strong>redux中执行异步任务</strong>(ajax, 定时器)</p><h5 id="使用异步中间件"><a href="#使用异步中间件" class="headerlink" title="使用异步中间件"></a>使用异步中间件</h5><p>​                   npm install –save redux-thunk</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯函数、高阶函数、函数柯里化</title>
      <link href="/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="纯函数、高阶函数、函数柯里化"><a href="#纯函数、高阶函数、函数柯里化" class="headerlink" title="纯函数、高阶函数、函数柯里化"></a>纯函数、高阶函数、函数柯里化</h4><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>​            1. 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</p><p>​            2. 必须遵守以下一些约束 </p><p>​                           (1) 不得改写参数数据</p><p>​                           (2) 不会产生任何副作用，例如网络请求，输入和输出设备</p><p>​                           (3) 不能调用Date.now()或者Math.random()等不纯的方法 </p><p>​            3. redux的reducer函数必须是一个纯函数</p><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>​            1. 理解: 一类特别的函数</p><p>​                    (1) 情况1: 参数是函数</p><p>​                    (2) 情况2: 返回是函数</p><p>​            2. 常见的高阶函数: </p><p>​                    (1) 定时器设置函数</p><p>​                    (2) 数组的forEach()/map()/filter()/reduce()/find()/bind()</p><p>​                    (3) promise</p><p>​                    (4) react-redux中的connect函数</p><p>​             3. 作用: 能实现更加动态, 更加可扩展的功能</p><h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><p>​            函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 </p><p>​          </p><pre class="line-numbers language-none"><code class="language-none">function sum(a)&#123;          return  (b)&#x3D;&gt;&#123;                  return  (c)&#x3D;&gt;&#123;                         return a+b+c                         &#125;                  &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux</title>
      <link href="/2022/01/16/react-redux/"/>
      <url>/2022/01/16/react-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​            1. 一个react插件库</p><p>​            2. 专门用来简化react应用中使用redux</p><h4 id="react-Redux将所有组件分成两大类"><a href="#react-Redux将所有组件分成两大类" class="headerlink" title="react-Redux将所有组件分成两大类"></a>react-Redux将所有组件分成两大类</h4><p>​            1. UI组件</p><p>​                  (1) 只负责 UI 的呈现，不带有任何业务逻辑</p><p>​                  (2) 通过props接收数据(一般数据和函数)</p><p>​                  (3) 不使用任何 Redux 的 API</p><p>​                  (4) 一般保存在components文件夹下</p><p>​            2. 容器组件</p><p>​                  (1) 负责管理数据和业务逻辑，不负责UI的呈现</p><p>​                  (2) 使用 Redux 的 API</p><p>​                  (3) 一般保存在containers文件夹下</p><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><p>​                 1. Provider：让所有组件都可以得到state数据</p><p>​                 2. connect：用于包装 UI 组件生成容器组件</p><p>​                 3. mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性</p><p>​                 4. mapDispatchToProps：将分发action的函数转换为UI组件的标签属性</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react路由</title>
      <link href="/2022/01/16/react%E8%B7%AF%E7%94%B1/"/>
      <url>/2022/01/16/react%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h4><p>​                1. 单页Web应用（single page web application，SPA）。</p><p>​                2. 整个应用只有<strong>一个完整的页面</strong>。</p><p>​                3. 点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</p><p>​                4. 数据都需要通过ajax请求获取, 并在前端异步展现。</p><h4 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h4><h5 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由?"></a>1.什么是路由?</h5><p>​                          (1). 一个路由就是一个映射关系(key:value)</p><p>​                          (2). key为路径, value可能是function或component</p><h5 id="2-路由分类"><a href="#2-路由分类" class="headerlink" title="2.路由分类"></a>2.路由分类</h5><h6 id="1-后端路由："><a href="#1-后端路由：" class="headerlink" title="(1). 后端路由："></a>(1). 后端路由：</h6><p>​                           (1) 理解： value是function, 用来处理客户端提交的请求。</p><p>​                           (2) 注册路由： router.get(path, function(req, res))</p><p>​                           (3) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p><h6 id="2-前端路由："><a href="#2-前端路由：" class="headerlink" title="(2). 前端路由："></a>(2). 前端路由：</h6><p>​                           (1) 浏览器端路由，value是component，用于展示页面内容。</p><p>​                           (2) 注册路由: &lt; Route path=”/test” component={Test} &gt;</p><p>​                           (3) 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p><h4 id="react-router-dom的理解"><a href="#react-router-dom的理解" class="headerlink" title="react-router-dom的理解"></a>react-router-dom的理解</h4><p>​                           (1). react的一个插件库。</p><p>​                           (2). 专门用来实现一个SPA应用。</p><p>​                           (3). 基于react的项目基本都会用到此库。</p><h4 id="react-router-dom相关API"><a href="#react-router-dom相关API" class="headerlink" title="react-router-dom相关API"></a><strong>react-router-dom相关API</strong></h4><h5 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h5><p>​                        1. &lt; BrowserRouter &gt;</p><p>​                        2. &lt; HashRouter &gt;</p><p>​                        3. &lt; Route &gt;</p><p>​                        4. &lt; Redirect &gt;</p><p>​                        5. &lt; Link &gt;</p><p>​                        6. &lt; NavLink &gt;</p><p>​                        7. &lt; Switch &gt;</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>​                        1. history对象</p><p>​                        2. match对象</p><p>​                        3. withRouter函数        </p><h4 id="基本路由使用"><a href="#基本路由使用" class="headerlink" title="基本路由使用"></a>基本路由使用</h4><p>​                       1. 下载 react-router-dom:  npm install –save react-router-dom</p><p>​                       2. 引入bootstrap.css: &lt; link rel=”stylesheet” href=”/css/bootstrap.css” &gt;</p><p>​                                (1).明确好界面中的导航区、展示区</p><p>​                                (2).导航区的a标签改为Link标签&lt; Link to=”/xxxxx” &gt;Demo&lt;/ Link &gt;</p><p>​                                (3).展示区写Route标签进行路径的匹配&lt; Route path=’/xxxx’ component={Demo}/ &gt;</p><p>​                                (4).&lt; App &gt;的最外侧包裹了一个&lt; BrowserRouter &gt;或&lt; HashRouter &gt;</p><h4 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h4><p>​                         1.写法不同：</p><p>​                                     一般组件：&lt; Demo/ &gt;</p><p>​                                    路由组件：&lt; Route path=”/demo” component={Demo}/ &gt;</p><p>​                          2.存放位置不同：</p><p>​                                            一般组件：components</p><p>​                                            路由组件：pages</p><p>​                         3.接收到的props不同：</p><p>​                                            一般组件：写组件标签时传递了什么，就能收到什么</p><p>​                                            路由组件：接收到三个固定的属性history、location、match</p><h4 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a><strong>NavLink与封装NavLink</strong></h4><p>​                              1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</p><h4 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a><strong>Switch的使用</strong></h4><p>​    1.通常情况下，path和component是一一对应的关系。</p><p>​    2.Switch可以提高路由匹配效率(单一匹配)。</p><h4 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a><strong>解决多级路径刷新页面样式丢失的问题</strong></h4><p>​     1.public/index.html 中 引入样式时不写 ./ 写 / （常用）</p><p>​        2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）</p><p>​        3.使用HashRouter</p><h4 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a><strong>路由的严格匹配与模糊匹配</strong></h4><p>​    1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</p><p>​        2.开启严格匹配：&lt; Route exact={true} path=”/about” component={About} &gt;</p><p>​        3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</p><h4 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a><strong>Redirect的使用</strong></h4><p> 1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由</p><h4 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a><strong>向路由组件传递参数</strong></h4><p> <strong>1.params参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=’/demo/test/tom/18’} &gt;详情&lt; /Link &gt;</p><p>​              注册路由(声明接收)：&lt; Route path=”/demo/test/:name/:age” component={Test}/ &gt;</p><p>​              接收参数：this.props.match.params</p><p>​        <strong>2.search参数</strong></p><p>​              路由链接(携带参数)：&lt;Link to=’/demo/test?name=tom&amp;age=18’}&gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.search</p><p>​              备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p><p>​       <strong>3.state参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=*{* **{**pathname:’/demo/test’,state:{name:’tom’,age:18}**}** *}* &gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.state</p><p>​              备注：刷新也可以保留住参数</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-ajax</title>
      <link href="/2022/01/16/react-ajax/"/>
      <url>/2022/01/16/react-ajax/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​     1. React本身只关注于界面, 并不包含发送ajax请求的代码</p><p>​     2. 前端应用需要通过ajax请求与后台进行交互(json数据)</p><p>​     3. react应用中需要集成第三方ajax库(或自己封装)</p><h3 id="常用的ajax请求库"><a href="#常用的ajax请求库" class="headerlink" title="常用的ajax请求库"></a>常用的ajax请求库</h3><p>​       1. jQuery: 比较重, 如果需要另外引入不建议使用</p><p>​       2. axios: 轻量级, 建议使用</p><p>​                 (1) 封装XmlHttpRequest对象的ajax</p><p>​                 (2) promise风格</p><p>​                 (3) 可以用在浏览器端和node服务器端</p><h3 id="消息订阅-发布机制"><a href="#消息订阅-发布机制" class="headerlink" title="消息订阅-发布机制"></a>消息订阅-发布机制</h3><p>​      1. 工具库: PubSubJS</p><p>​      2. 下载: npm install pubsub-js –save </p><p>​      3. 使用: </p><p>​              (1) import PubSub from ‘pubsub-js’ //引入</p><p>​              (2) PubSub.subscribe(‘delete’, function(data){ }); //订阅</p><p>​              (3) PubSub.publish(‘delete’, data) //发布消息</p><h3 id="扩展：Fetch"><a href="#扩展：Fetch" class="headerlink" title="扩展：Fetch"></a>扩展：Fetch</h3><h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>​            1. <a href="https://github.github.io/fetch/">https://github.github.io/fetch/</a></p><p>​            2. <a href="https://segmentfault.com/a/1190000003810652">https://segmentfault.com/a/1190000003810652</a></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>​              1. fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求</p><p>​              2. 老版本浏览器可能不支持</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架</title>
      <link href="/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h3><p>​            1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目</p><p>​                     (1). 包含了所有需要的配置（语法检查、jsx编译、devServer…）</p><p>​                     (2). 下载好了所有相关的依赖</p><p>​                     (3). 可以直接运行一个简单效果</p><p>​            2. react提供了一个用于创建react项目的脚手架库: create-react-app</p><p>​            3. 项目的整体技术架构为:  react + webpack + es6 + eslint</p><p>​            4. 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</p><h5 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h5><p>​                    <strong>第一步</strong>，全局安装：npm i -g create-react-app</p><p>​                    <strong>第二步</strong>，切换到想创项目的目录，使用命令：create-react-app hello-react</p><p>​                    <strong>第三步</strong>，进入项目文件夹：cd hello-react</p><p>​                    <strong>第四步</strong>，启动项目：npm start</p><h4 id="react脚手架项目结构"><a href="#react脚手架项目结构" class="headerlink" title="react脚手架项目结构"></a>react脚手架项目结构</h4><p>​            public —- 静态资源文件夹</p><p>​                            favicon.icon —— 网站页签图标</p><p>​                            <strong>index.html ——– 主页面</strong></p><p>​                            logo192.png ——- logo图</p><p>​                            logo512.png ——- logo图</p><p>​                            manifest.json —– 应用加壳的配置文件</p><p>​                            robots.txt ——– 爬虫协议文件</p><p>​            src —- 源码文件夹</p><p>​                           App.css ——– App组件的样式</p><p>​                           <strong>App.js ——— App组件</strong></p><p>​                           App.test.js —- 用于给App做测试</p><p>​            index.css —— 样式</p><p>​                            <strong>index.js —— 入口文件</strong></p><p>​                            logo.svg ——- logo图</p><p>​                            reportWebVitals.js — 页面性能分析文件(需要web-vitals库的支持)</p><p>​                            setupTests.js</p><h4 id="功能界面的组件化编码流程（通用）"><a href="#功能界面的组件化编码流程（通用）" class="headerlink" title="功能界面的组件化编码流程（通用）"></a>功能界面的组件化编码流程（通用）</h4><p>​     1. 拆分组件: 拆分界面,抽取组件</p><p>​     2. 实现静态组件: 使用组件实现静态页面效果</p><p>​     3. 实现动态组件</p><p>​                   (1) 动态显示初始化数据</p><p>​                              ① 数据类型</p><p>​                              ② 数据名称</p><p>​                              ③ 保存在哪个组件?</p><p>​                   (2)交互(从绑定事件监听开始)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-jsx</title>
      <link href="/2022/01/14/react-jsx/"/>
      <url>/2022/01/14/react-jsx/</url>
      
        <content type="html"><![CDATA[<ol><li><p>全称:  JavaScript XML</p></li><li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是 <strong>React.createElement(component,props,…children)</strong> 方法的语法糖</p></li><li><p>作用: 用来简化创建虚拟DOM </p></li></ol><p>​         (1) 写法：<strong>var  ele = &lt; h3 &gt; hello,jsx!&lt; /h3 &gt;</strong></p><p>​         (2) 注意1：它不是字符串, 也不是HTML/XML标签</p><p>​         (3) 注意2：它最终产生的就是一个JS对象</p><ol start="4"><li><p>标签名任意: HTML标签或其它标签</p></li><li><p>标签属性任意: HTML标签属性或其它</p></li><li><p>基本语法规则</p><p>(1). 遇到 &lt;开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</p><p>(2).遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含</p><p>(3).定义虚拟DOM时，不要写引号</p><p>(4).样式的类名指定不要用class，要用className</p><p>(5).内联样式，要用style= <strong>{</strong>{key:value}<strong>}</strong> 的形式去写</p><p>(6).只有一个根标签</p><p>(7).标签必须闭合</p><p>(8).标签首字母</p><p>​         ①.若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错</p><p>​         ②.若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中key的作用</title>
      <link href="/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题:"></a>经典面试题:</h3><p>   <em>一. react/vue中的key有什么作用？（key的内部原理是什么？）</em></p><p>   <em>二. 为什么遍历列表时，key最好不要用index?</em></p><p>​    <strong>1. 虚拟DOM中key的作用：</strong></p><p>​      （1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p><p>​      （2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>​                 ①. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>​                         a.若虚拟DOM中内容没变, 直接使用之前的真实DOM</p><p>​                         b.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>​                 ②. 旧虚拟DOM中未找到与新虚拟DOM相同的key根据数据创建新的真实DOM，随后渲染到到页面</p><p>​    <strong>2.用index作为key可能会引发的问题：</strong></p><p>​       (1). 若对数据进行：逆序添加、逆序删除等破坏顺序操作,会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p><p>​       (2). 如果结构中还包含输入类的DOM,会产生错误DOM更新 ==&gt; 界面有问题。</p><p>​       (3). 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><p>​          </p><p>​    <strong>3. 开发中如何选择key:</strong></p><p>​      (1).最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p><p>​      (2).如果确定只是简单的展示数据，用index也是可以的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react生命周期</title>
      <link href="/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>​        1. 组件从创建到死亡它会经历一些特定的阶段。</p><p>​        2. React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</p><p>​        3. 我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</p><h3 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h3><p><img src="/2022/01/14/react生命周期/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>生命周期的三个阶段</p><p>​           <strong>1.初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p><p>​                            (1). constructor()</p><p>​                            (2).getDerivedStateFromProps</p><p>​                            (3). render()</p><p>​                            (4). componentDidMount()</p><p>​           <strong>2.更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p><p>​                            (1).getDerivedStateFromProps</p><p>​                            (2). shouldComponentUpdate()</p><p>​                            (3). render()</p><p>​                            (4). getSnapshotBeforeUpdate</p><p>​                            (5). componentDidUpdate()</p><p>​           <strong>3.卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发</p><p>​                            (1). componentWillUnmount()</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件的三大核心属性</title>
      <link href="/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​                        1. state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</p><p>​                        2. 组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</p><h4 id="强烈注意"><a href="#强烈注意" class="headerlink" title="强烈注意"></a>强烈注意</h4><p>​                        1. 组件中render方法中的this为组件实例对象</p><p>​                        2. 组件自定义的方法中this为undefined，如何解决？</p><p>​                                 ① 强制绑定this: 通过函数对象的bind()</p><p>​                                 ② 箭头函数</p><p>​                        3. 状态数据，不能直接修改或更新</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>​                       1. 每个组件对象都会有props(properties的简写)属性</p><p>​                       2. 组件标签的所有属性都保存在props中</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​                       1. 通过标签属性从组件外向组件内传递变化的数据</p><p>​                       2. 注意: 组件内部不要修改props数据</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>​                       1. 内部读取某个属性值</p><p>​                                <strong>this.props.name</strong></p><p>​                       2. 对props中的属性值进行类型限制和必要性限制</p><p>​                                使用prop-types库进限制（需要引入prop-types库）</p><p>​                                        <strong>Person.propTypes = {</strong></p><p>​                                                <strong>name: PropTypes.string.isRequired,</strong></p><p>​                                                <strong>age: PropTypes.number</strong></p><p>​                                        <strong>}</strong></p><p>​                       3. 扩展属性: 将对象的所有属性通过props传递</p><p>​                                <strong>&lt;Person {…person}/&gt;</strong></p><p>​                       4.默认属性值</p><p>​                                   <strong>Person.defaultProps = {</strong></p><p>​                                            <strong>age: 18,</strong></p><p>​                                            <strong>sex: “男”</strong></p><p>​                                    <strong>}</strong></p><p>​                       5.组件类的构造函数</p><p>​                                   <strong>constructor(props){</strong></p><p>​                                         <strong>super(props)</strong>    </p><p>​                                    <strong>}</strong></p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><p>​                      组件内的标签可以定义ref属性来标识自己</p><h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>​                    1.字符串形式的ref         </p><p>​                                    <strong>&lt; input ref=”input1”/ &gt;</strong>                </p><p>​                    2.回调形式的ref</p><p>​                                    <strong>&lt;input ref={(c)=&gt;{this.input1 = c}}/&gt;</strong>        </p><p>​                    3.create创建ref容器</p><p>​                                    <strong>myRef = React.createRef()</strong></p><p>​                                    <strong>&lt; input ref={this.myRef}/ &gt;</strong>        </p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>​        1. 通过onXxx属性指定事件处理函数(注意大小写)</p><p>​                （1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</p><p>​                （2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</p><p>​       2. 通过event.target得到发生事件的DOM元素对象</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块与组件、模块化与组件化的理解</title>
      <link href="/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    1. 理解：向外提供特定功能的js程序, 一般就是一个js文件</p><p>​    2. 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。</p><p>​    3. 作用：复用js, 简化js的编写, 提高js运行效率</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>​    1. 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)</p><p>​    2. 为什么要用组件： 一个界面的功能更复杂</p><p>​    3. 作用：复用编码, 简化项目编码, 提高运行效率</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    当应用的js都以模块来编写的, 这个应用就是一个模块化的应用</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>​    当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react介绍描述</title>
      <link href="/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/"/>
      <url>/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍描述"><a href="#介绍描述" class="headerlink" title="介绍描述"></a>介绍描述</h3><ol><li><p>用于动态构建用户界面的 JavaScript 库(只关注于视图)</p></li><li><p>由Facebook开源</p></li></ol><h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol><li><p>声明式编码</p></li><li><p>组件化编码</p></li><li><p>React Native 编写原生应用</p></li><li><p>高效（优秀的Diffing算法）</p></li></ol><h3 id="React高效的原因"><a href="#React高效的原因" class="headerlink" title="React高效的原因"></a>React高效的原因</h3><ol><li><p>使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。</p></li><li><p>DOM Diffing算法, 最小化页面重绘。</p></li></ol><h3 id="虚拟DOM与真实DOM"><a href="#虚拟DOM与真实DOM" class="headerlink" title="虚拟DOM与真实DOM"></a>虚拟DOM与真实DOM</h3><ol><li><p>React提供了一些API来创建一种 “特别” 的一般js对象</p><p><strong>const    VDOM = React.createElement(‘xx’,{id:’xx’},’xx’)</strong></p><p>上面创建的就是一个简单的虚拟DOM对象</p></li><li><p>虚拟DOM对象最终都会被React转换为真实的DOM</p></li><li><p>我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
