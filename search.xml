<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue路由</title>
      <link href="/2022/04/12/Vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2022/04/12/Vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</p></li><li><p>前端路由：key是路径，value是组件。路由</p></li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li>安装vue-router，命令：<code>npm i vue-router</code></li></ol><ol start="2"><li>应用插件：<code>Vue.use(VueRouter)</code></li></ol><ol start="3"><li>编写router配置项:</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  &#x2F;&#x2F;引入VueRouter  import VueRouter from &#39;vue-router&#39;  &#x2F;&#x2F;引入Luyou 组件  import About from &#39;..&#x2F;components&#x2F;About&#39;  import Home from &#39;..&#x2F;components&#x2F;Home&#39;    &#x2F;&#x2F;创建router实例对象，去管理一组一组的路由规则  const router &#x3D; new VueRouter(&#123;   routes:[​     &#123;​      path:&#39;&#x2F;about&#39;,​      component:About​     &#125;,​     &#123;​      path:&#39;&#x2F;home&#39;,​      component:Home​     &#125;   ]  &#125;)    &#x2F;&#x2F;暴露router  export default router  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>实现切换（active-class可配置高亮样式）</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;vue &lt;router-link active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt; \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>指定展示位置</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;vue&lt;router-view&gt;&lt;&#x2F;router-view&gt;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li><p>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p></li><li><p>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p></li><li><p>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p></li><li><p>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</p></li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li>配置路由规则，使用children配置项：</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  routes:[   &#123;​     path:&#39;&#x2F;about&#39;,​     component:About,   &#125;,   &#123;​     path:&#39;&#x2F;home&#39;,​     component:Home,​     children:[ &#x2F;&#x2F;通过children配置子级路由​      &#123;​        path:&#39;news&#39;, &#x2F;&#x2F;此处一定不要写：&#x2F;news​        component:News​      &#125;,​      &#123;​        path:&#39;message&#39;,&#x2F;&#x2F;此处一定不要写：&#x2F;message​        component:Message​      &#125;​     ]   &#125;  ]  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>跳转（要写完整路径）：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;vue&lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol><li>传递参数</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;vue  &lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;  &lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;​          &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;  &lt;router-link    :to&#x3D;&quot;&#123;​     path:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,​     query:&#123;​      id:666,​        title:&#39;你好&#39;​     &#125;   &#125;&quot;  \&gt;跳转&lt;&#x2F;router-link&gt;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>接收参数：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js$route.query.id$route.query.title\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li>作用：可以简化路由的跳转。</li></ol><ol start="2"><li>如何使用</li></ol><p>  (1). 给路由命名：</p><pre class="line-numbers language-none"><code class="language-none">   \&#96;&#96;&#96;js   &#123;​     path:&#39;&#x2F;demo&#39;,​     component:Demo,​     children:[​      &#123;​        path:&#39;test&#39;,​        component:Test,​        children:[​         &#123;​              name:&#39;hello&#39; &#x2F;&#x2F;给路由命名​           path:&#39;welcome&#39;,​           component:Hello,​         &#125;​        ]​      &#125;​     ]   &#125;   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  (2). 简化跳转：</p><pre class="line-numbers language-none"><code class="language-none">   \&#96;&#96;&#96;vue   &lt;!--简化前，需要写完整的路径 --&gt;   &lt;router-link to&#x3D;&quot;&#x2F;demo&#x2F;test&#x2F;welcome&quot;&gt;跳转&lt;&#x2F;router-link&gt;      &lt;!--简化后，直接通过名字跳转 --&gt;   &lt;router-link :to&#x3D;&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;      &lt;!--简化写法配合传递参数 --&gt;   &lt;router-link ​     :to&#x3D;&quot;&#123;​      name:&#39;hello&#39;,​      query:&#123;​        id:666,​         title:&#39;你好&#39;​      &#125;​     &#125;&quot;   \&gt;跳转&lt;&#x2F;router-link&gt;   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol><li>配置路由，声明接收params参数</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  &#123;   path:&#39;&#x2F;home&#39;,   component:Home,   children:[​     &#123;​      path:&#39;news&#39;,​      component:News​     &#125;,​     &#123;​      component:Message,​      children:[​        &#123;​         name:&#39;xiangqing&#39;,​         path:&#39;detail&#x2F;:id&#x2F;:title&#39;, &#x2F;&#x2F;使用占位符声明接收params参数​         component:Detail​        &#125;​      ]​     &#125;   ]  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>传递参数</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;vue  &lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;  &lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;666&#x2F;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;​          &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;  &lt;router-link    :to&#x3D;&quot;&#123;​     name:&#39;xiangqing&#39;,​     params:&#123;​      id:666,​        title:&#39;你好&#39;​     &#125;   &#125;&quot;  \&gt;跳转&lt;&#x2F;router-link&gt;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  &gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p><ol start="3"><li>接收参数：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js$route.params.id$route.params.title\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>  作用：让路由组件更方便的收到参数</p><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#123;  name:&#39;xiangqing&#39;,  path:&#39;detail&#x2F;:id&#39;,  component:Detail,  &#x2F;&#x2F;第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件  &#x2F;&#x2F; props:&#123;a:900&#125;  &#x2F;&#x2F;第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件  &#x2F;&#x2F; props:true    &#x2F;&#x2F;第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件  props(route)&#123;   return &#123;​     id:route.query.id,​     title:route.query.title   &#125;  &#125;&#125;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt; router-link &gt;的replace属性"></a>8.&lt; router-link &gt;的replace属性</h3><ol><li><p>作用：控制路由跳转时操作浏览器历史记录的模式</p></li><li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p></li><li><p>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></p></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</li></ol><ol start="2"><li>具体编码：</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  &#x2F;&#x2F;$router的两个API  this.$router.push(&#123;   name:&#39;xiangqing&#39;,​     params:&#123;​      id:xxx,​      title:xxx​     &#125;  &#125;)    this.$router.replace(&#123;   name:&#39;xiangqing&#39;,​     params:&#123;​      id:xxx,​      title:xxx​     &#125;  &#125;)  this.$router.forward() &#x2F;&#x2F;前进  this.$router.back() &#x2F;&#x2F;后退  this.$router.go() &#x2F;&#x2F;可前进也可后退  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li>作用：让不展示的路由组件保持挂载，不被销毁。</li></ol><ol start="2"><li>具体编码：</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;vue  &lt;keep-alive include&#x3D;&quot;News&quot;&gt; ​    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;keep-alive&gt;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p></li><li><p>具体名字：</p></li></ol><p>  (1). <code>activated</code>路由组件被激活时触发。</p><p>  (2). <code>deactivated</code>路由组件失活时触发。</p><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li>作用：对路由进行权限控制</li></ol><ol start="2"><li>分类：全局守卫、独享守卫、组件内守卫</li></ol><ol start="3"><li>全局守卫:</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js  &#x2F;&#x2F;全局前置守卫：初始化时执行、每次路由切换前执行  router.beforeEach((to,from,next)&#x3D;&gt;&#123;   console.log(&#39;beforeEach&#39;,to,from)   if(to.meta.isAuth)&#123; &#x2F;&#x2F;判断当前路由是否需要进行权限控制​     if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123; &#x2F;&#x2F;权限控制的具体规则​      next() &#x2F;&#x2F;放行​     &#125;else&#123;​      alert(&#39;暂无权限查看&#39;)​      &#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)​     &#125;   &#125;else&#123;​     next() &#x2F;&#x2F;放行   &#125;  &#125;)    &#x2F;&#x2F;全局后置守卫：初始化时执行、每次路由切换后执行  router.afterEach((to,from)&#x3D;&gt;&#123;   console.log(&#39;afterEach&#39;,to,from)   if(to.meta.title)&#123; ​     document.title &#x3D; to.meta.title &#x2F;&#x2F;修改网页的title   &#125;else&#123;​     document.title &#x3D; &#39;vue_test&#39;   &#125;  &#125;)  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>独享守卫:</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  beforeEnter(to,from,next)&#123;   console.log(&#39;beforeEnter&#39;,to,from)   if(to.meta.isAuth)&#123; &#x2F;&#x2F;判断当前路由是否需要进行权限控制​     if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;​      next()​     &#125;else&#123;​      alert(&#39;暂无权限查看&#39;)​      &#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)​     &#125;   &#125;else&#123;​     next()   &#125;  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>组件内守卫：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#x2F;&#x2F;进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,&#x2F;&#x2F;离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p></li><li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p></li><li><p>hash模式：</p></li></ol><p>  (1). 地址中永远带着#号，不美观 。</p><p>  (2). 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</p><p>  (3). 兼容性较好。</p><ol start="4"><li>history模式：</li></ol><p>  (1). 地址干净，美观 。</p><p>  (2). 兼容性和hash模式相比略差。</p><p>  (3). 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2022/04/12/Vuex/"/>
      <url>/2022/04/12/Vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>   在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a><strong>2.何时使用？</strong></h3><p>   多个组件需要共享数据时</p><h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol><li>创建文件：<code>src/store/index.js</code></li></ol><pre class="line-numbers language-none"><code class="language-none"> \&#96;&#96;&#96;js &#x2F;&#x2F;引入Vue核心库 import Vue from &#39;vue&#39; &#x2F;&#x2F;引入Vuex import Vuex from &#39;vuex&#39; &#x2F;&#x2F;应用Vuex插件 Vue.use(Vuex) &#x2F;&#x2F; 准备actions对象——响应组件中用户的动作 const actions &#x3D; &#123;&#125; &#x2F;&#x2F;准备mutations对象——修改state中的数据 const mutations &#x3D; &#123;&#125; &#x2F;&#x2F;准备state对象——保存具体的数据 const state &#x3D; &#123;&#125;  &#x2F;&#x2F;创建并暴露store export default new Vuex.Store(&#123;  actions,  mutations,  state &#125;) \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js......&#x2F;&#x2F;引入storeimport store from &#39;.&#x2F;store&#39;......&#x2F;&#x2F;创建vmnew Vue(&#123; el:&#39;#app&#39;, render: h &#x3D;&gt; h(App), store&#125;)\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol><li>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  &#x2F;&#x2F;引入Vue核心库  import Vue from &#39;vue&#39;  &#x2F;&#x2F;引入Vuex  import Vuex from &#39;vuex&#39;  &#x2F;&#x2F;引用Vuex  Vue.use(Vuex)    const actions &#x3D; &#123;​    &#x2F;&#x2F;响应组件中加的动作   jia(context,value)&#123;​     &#x2F;&#x2F; console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)​     context.commit(&#39;JIA&#39;,value)   &#125;,  &#125;    const mutations &#x3D; &#123;​    &#x2F;&#x2F;执行加   JIA(state,value)&#123;​     &#x2F;&#x2F; console.log(&#39;mutations中的JIA被调用了&#39;,state,value)​     state.sum +&#x3D; value   &#125;  &#125;    &#x2F;&#x2F;初始化数据  const state &#x3D; &#123;   sum:0  &#125;    &#x2F;&#x2F;创建并暴露store  export default new Vuex.Store(&#123;   actions,   mutations,   state,  &#125;)  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>组件中读取vuex中的数据：<code>$store.state.sum</code></li></ol><ol start="3"><li>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></li></ol><p>  &gt;  备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p><h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol><li>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</li></ol><ol start="2"><li>在<code>store.js</code>中追加<code>getters</code>配置</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  ......    const getters &#x3D; &#123;   bigSum(state)&#123;​     return state.sum * 10   &#125;  &#125;    &#x2F;&#x2F;创建并暴露store  export default new Vuex.Store(&#123;   ......   getters  &#125;)  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>组件中读取数据：<code>$store.getters.bigSum</code></li></ol><h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol><li><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  computed: &#123;​    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（对象写法）​    ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),​      ​    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（数组写法）​    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),  &#125;,  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  computed: &#123;​    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（对象写法）​    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),  ​    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（数组写法）​    ...mapGetters([&#39;bigSum&#39;])  &#125;,  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  methods:&#123;​    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（对象形式）​    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)  ​    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（数组形式）​    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  methods:&#123;​    &#x2F;&#x2F;靠mapActions生成：increment、decrement（对象形式）​    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),​    ​    &#x2F;&#x2F;靠mapMutations生成：JIA、JIAN（对象形式）​    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&gt; 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p><h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol><li>目的：让代码更好维护，让多种数据分类更加明确。</li></ol><ol start="2"><li>修改<code>store.js</code></li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;javascript  const countAbout &#x3D; &#123;   namespaced:true,&#x2F;&#x2F;开启命名空间   state:&#123;x:1&#125;,   mutations: &#123; ... &#125;,   actions: &#123; ... &#125;,   getters: &#123;​    bigSum(state)&#123;​     return state.sum * 10​    &#125;   &#125;  &#125;    const personAbout &#x3D; &#123;   namespaced:true,&#x2F;&#x2F;开启命名空间   state:&#123; ... &#125;,   mutations: &#123; ... &#125;,   actions: &#123; ... &#125;  &#125;    const store &#x3D; new Vuex.Store(&#123;   modules: &#123;​    countAbout,​    personAbout   &#125;  &#125;)  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>开启命名空间后，组件中读取state数据：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#x2F;&#x2F;方式一：自己直接读取this.$store.state.personAbout.list&#x2F;&#x2F;方式二：借助mapState读取：...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>开启命名空间后，组件中读取getters数据：</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#x2F;&#x2F;方式一：自己直接读取this.$store.getters[&#39;personAbout&#x2F;firstPersonName&#39;]&#x2F;&#x2F;方式二：借助mapGetters读取：...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>开启命名空间后，组件中调用dispatch</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#x2F;&#x2F;方式一：自己直接dispatchthis.$store.dispatch(&#39;personAbout&#x2F;addPersonWang&#39;,person)&#x2F;&#x2F;方式二：借助mapActions：...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>开启命名空间后，组件中调用commit</li></ol><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;js&#x2F;&#x2F;方式一：自己直接committhis.$store.commit(&#39;personAbout&#x2F;ADD_PERSON&#39;,person)&#x2F;&#x2F;方式二：借助mapMutations：...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2脚手架</title>
      <link href="/2022/04/08/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/04/08/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h3><pre class="line-numbers language-none"><code class="language-none">   ├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a><strong>关于不同版本的Vue</strong></h3><ol><li>vue.js与vue.runtime.xxx.js的区别：</li></ol><p>​       （1）. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</p><p>​       （2）. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</p><ol start="2"><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h3 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a><strong>vue.config.js配置文件</strong></h3><ol><li><p>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</p></li><li><p>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></p></li></ol><h3 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a><strong>ref属性</strong></h3><ol><li><p>被用来给元素或子组件注册引用信息（id的替代者）</p></li><li><p>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</p></li><li><p>使用方式：</p></li></ol><p>​        （1）. 打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></p><p>​        （2）. 获取：<code>this.$refs.xxx</code></p><h3 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a><strong>props配置项</strong></h3><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p></li></ol><p>(1). 第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p><p>(2). 第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p><p>(3). 第三种方式（限制类型、限制必要性、指定默认值）：</p><pre class="line-numbers language-none"><code class="language-none">   \&#96;&#96;&#96;js​    props:&#123;​      name:&#123;​        type:String, &#x2F;&#x2F;类型​        required:true, &#x2F;&#x2F;必要性​        default:&#39;老王&#39; &#x2F;&#x2F;默认值​      &#125;​    &#125;​    \&#96;&#96;&#96; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> &gt; 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a><strong>mixin(混入)</strong></h3><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p></li></ol><p>​    <strong>第一步定义混合：</strong></p><pre class="line-numbers language-none"><code class="language-none"> \&#96;&#96;&#96;  &#123;​    data()&#123;....&#125;,​    methods:&#123;....&#125;​    ....  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二步使用混入：</strong></p><p>   全局混入：<code>Vue.mixin(xxx)</code></p><p>   局部混入：<code>mixins:[&#39;xxx&#39;]  </code></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js  对象.install &#x3D; function (Vue, options) &#123;​    &#x2F;&#x2F; 1. 添加全局过滤器​    Vue.filter(....)​    &#x2F;&#x2F; 2. 添加全局指令​    Vue.directive(....)​    &#x2F;&#x2F; 3. 配置全局混入(合)​    Vue.mixin(....)​    &#x2F;&#x2F; 4. 添加实例方法​    Vue.prototype.$myMethod &#x3D; function () &#123;...&#125;​    Vue.prototype.$myProperty &#x3D; xxxx  &#125;  \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>使用插件：<code>Vue.use()</code></li></ol><h3 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h3><ol><li><p>作用：让样式在局部生效，防止冲突。</p></li><li><p>写法：<code>&lt;style scoped&gt;</code></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li>组件化编码流程：</li></ol><p>(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p>(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>  ①.一个组件在用：放在组件自身即可。</p><p>  ②. 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p>(3).实现交互：从绑定事件开始。</p><ol start="2"><li>props适用于：</li></ol><p>(1).父组件 ==&gt; 子组件 通信</p><p>(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p><ol start="3"><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a><strong>webStorage</strong></h3><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p></li></ol><p>(1). <code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p><p>​         该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p><p>(2). <code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p>该方法接受一个键名作为参数，返回键名对应的值。</p><p>(3). <code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p> 该方法接受一个键名作为参数，并把该键名从存储中删除。</p><p> (4). <code> xxxxxStorage.clear()</code></p><p>该方法会清空存储中的所有数据。</p><ol start="4"><li>备注：</li></ol><p>  (1). SessionStorage存储的内容会随着浏览器窗口关闭而消失。</p><p>  (2). LocalStorage存储的内容，需要手动清除才会消失。</p><p>  (3). <code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</p><p>  (4). <code>JSON.parse(null)</code>的结果依然是null。</p><h3 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a><strong>组件的自定义事件</strong></h3><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p></li></ol><p>  (1). 第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p><p>  (2). 第二种方式，在父组件中：</p><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js​    &lt;Demo ref&#x3D;&quot;demo&quot;&#x2F;&gt;​    ......​    mounted()&#123;​      this.$refs.xxx.$on(&#39;atguigu&#39;,this.test)​    &#125;​    \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  (3). 若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p><p>(4). 触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>   </p><p>(5). 解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p><p>(6). 组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p><p>(7). 注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p><h3 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a><strong>全局事件总线（GlobalEventBus）</strong></h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p></li></ol><pre class="line-numbers language-none"><code class="language-none"> \&#96;&#96;&#96;js  new Vue(&#123;   ......   beforeCreate() &#123;​     Vue.prototype.$bus &#x3D; this &#x2F;&#x2F;安装全局事件总线，$bus就是当前应用的vm   &#125;,​    ......  &#125;)   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>使用事件总线：</li></ol><p>  (1). 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><pre class="line-numbers language-none"><code class="language-none">   \&#96;&#96;&#96;js   methods()&#123;​    demo(data)&#123;......&#125;   &#125;   ......   mounted() &#123;​    this.$bus.$on(&#39;xxxx&#39;,this.demo)   &#125;   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  (2). 提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p><ol start="4"><li>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</li></ol><h3 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a><strong>消息订阅与发布（pubsub）</strong></h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p></li></ol><p>  (1). 安装pubsub：<code>npm i pubsub-js</code></p><p>  (2). 引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p><p>  (3). 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><pre class="line-numbers language-none"><code class="language-none">  \&#96;&#96;&#96;js   methods()&#123;​    demo(data)&#123;......&#125;   &#125;   ......   mounted() &#123;​    this.pid &#x3D; pubsub.subscribe(&#39;xxx&#39;,this.demo) &#x2F;&#x2F;订阅消息   &#125;   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  (4). 提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p><p>  (5). 最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><strong>nextTick</strong></h3><ol><li><p>语法：<code>this.$nextTick(回调函数)</code></p></li><li><p>作用：在下一次 DOM 更新结束后执行其指定的回调。</p></li><li><p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p></li></ol><h3 id="Vue封装的过渡与动画"><a href="#Vue封装的过渡与动画" class="headerlink" title="Vue封装的过渡与动画"></a><strong>Vue封装的过渡与动画</strong></h3><ol><li>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</li></ol><p>2.写法：</p><p>  (1). 准备好样式：</p><p>   - 元素进入的样式：</p><p>​    ①. v-enter：进入的起点</p><p>​    ②. v-enter-active：进入过程中</p><p>​    ③. v-enter-to：进入的终点</p><p>   - 元素离开的样式：</p><p>​    ①. v-leave：离开的起点</p><p>​    ②. v-leave-active：离开过程中</p><p>​    ③. v-leave-to：离开的终点</p><p>  (2). 使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><pre class="line-numbers language-none"><code class="language-none">   \&#96;&#96;&#96;vue   &lt;transition name&#x3D;&quot;hello&quot;&gt;​     &lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好啊！&lt;&#x2F;h1&gt;   &lt;&#x2F;transition&gt;   \&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  (3). 备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p><h3 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a><strong>vue脚手架配置代理</strong></h3><p><strong>方法一</strong></p><pre class="line-numbers language-none"><code class="language-none">  在vue.config.js中添加如下配置：\&#96;&#96;&#96;jsdevServer:&#123; proxy:&quot;http:&#x2F;&#x2F;localhost:5000&quot;&#125;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p>(1). 优点：配置简单，请求资源时直接发给前端（8080）即可。</p><p>(2). 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</p><p>(3). 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</p><p><strong>方法二</strong></p><p>  编写vue.config.js配置具体代理规则：</p><pre class="line-numbers language-none"><code class="language-none">\&#96;&#96;&#96;jsmodule.exports &#x3D; &#123;  devServer: &#123;   proxy: &#123;   &#39;&#x2F;api1&#39;: &#123;&#x2F;&#x2F; 匹配所有以 &#39;&#x2F;api1&#39;开头的请求路径​    target: &#39;http:&#x2F;&#x2F;localhost:5000&#39;,&#x2F;&#x2F; 代理目标的基础路径​    changeOrigin: true,​    pathRewrite: &#123;&#39;^&#x2F;api1&#39;: &#39;&#39;&#125;   &#125;,   &#39;&#x2F;api2&#39;: &#123;&#x2F;&#x2F; 匹配所有以 &#39;&#x2F;api2&#39;开头的请求路径​    target: &#39;http:&#x2F;&#x2F;localhost:5001&#39;,&#x2F;&#x2F; 代理目标的基础路径​    changeOrigin: true,​    pathRewrite: &#123;&#39;^&#x2F;api2&#39;: &#39;&#39;&#125;   &#125;  &#125; &#125;&#125;&#x2F;*  changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000  changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080  changeOrigin默认值为true*&#x2F;\&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p>(1). 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</p><p>(2). 缺点：配置略微繁琐，请求资源时必须加前缀。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a><strong>插槽</strong></h3><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><p>(1). 默认插槽：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;vue      父组件中：              &lt;Category&gt;                 &lt;div&gt;html结构1&lt;&#x2F;div&gt;              &lt;&#x2F;Category&gt;      子组件中：              &lt;template&gt;                  &lt;div&gt;                     &lt;!-- 定义插槽 --&gt;                     &lt;slot&gt;插槽默认内容...&lt;&#x2F;slot&gt;                  &lt;&#x2F;div&gt;              &lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2). 具名插槽：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">父组件中：        &lt;Category&gt;            &lt;template slot&#x3D;&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;&#x2F;div&gt;            &lt;&#x2F;template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;&#x2F;div&gt;            &lt;&#x2F;template&gt;        &lt;&#x2F;Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name&#x3D;&quot;center&quot;&gt;插槽默认内容...&lt;&#x2F;slot&gt;               &lt;slot name&#x3D;&quot;footer&quot;&gt;插槽默认内容...&lt;&#x2F;slot&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>(3). 作用域插槽：</strong></p><p> ①.理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）<br>②. 具体编码：</p><pre><code>     <pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">父组件中：&lt;Category&gt;&lt;template scope&#x3D;&quot;scopeData&quot;&gt;&lt;!-- 生成的是ul列表 --&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;g in scopeData.games&quot; :key&#x3D;&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;&#x2F;Category&gt;&lt;Category&gt;&lt;template slot-scope&#x3D;&quot;scopeData&quot;&gt;&lt;!-- 生成的是h4标题 --&gt;&lt;h4 v-for&#x3D;&quot;g in scopeData.games&quot; :key&#x3D;&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;h4&gt;&lt;&#x2F;template&gt;&lt;&#x2F;Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games&#x3D;&quot;games&quot;&gt;&lt;&#x2F;slot&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;template&gt;        &lt;script&gt;            export default &#123;                name:&#39;Category&#39;,                props:[&#39;title&#39;],                &#x2F;&#x2F;数据在子组件自身                data() &#123;                    return &#123;                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]                    &#125;                &#125;,            &#125;        &lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2</title>
      <link href="/2022/04/08/vue2/"/>
      <url>/2022/04/08/vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h3 id="初始Vue"><a href="#初始Vue" class="headerlink" title="初始Vue"></a>初始Vue</h3><p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p><p>2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p><p>3.root容器里的代码被称为【Vue模板】；</p><p>4.Vue实例和容器是一一对应的；</p><p>5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p><p>6.中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p><p>7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p><p><span style="color:red;"><strong>注意区分：js表达式 和 js代码(语句)</strong></span></p><p>​       1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：</p><p>​            (1). a</p><p>​            (2). a+b</p><p>​            (3). demo(1)</p><p>​            (4). x === y ? ‘a’ : ‘b’</p><p>2.js代码(语句)</p><p>​            (1). if(){}</p><p>​            (2). for(){}</p><h3 id="Vue的模板语法"><a href="#Vue的模板语法" class="headerlink" title="Vue的模板语法"></a><strong>Vue的模板语法</strong></h3><p><em><strong>Vue模板语法有2大类：</strong></em></p><p>​     <strong>1.插值语法：</strong></p><p>​       功能：用于解析标签体内容。</p><p>​       写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p><p>​     <strong>2.指令语法：</strong></p><p>​       功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p><p>​       举例：v-bind:href=”xxx” 或  简写为 :href=”xxx”，xxx同样要写js表达式,且可以直接读取到data中的所有属性。</p><p>​       备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a><strong>数据绑定</strong></h3><p><strong>Vue中有2种数据绑定的方式：</strong></p><p>​       1.单向绑定(v-bind)：数据只能从data流向页面。</p><p>​       2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p><p>​     备注：</p><p>​       1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>​       2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p><h3 id="data与el的两种写法"><a href="#data与el的两种写法" class="headerlink" title="data与el的两种写法"></a><strong>data与el的两种写法</strong></h3><p><em><strong>data与el的2种写法</strong></em></p><p>​      <strong>1.el有2种写法</strong></p><p>​        (1).new Vue时候配置el属性。</p><p>​        (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p><p>​      <strong>2.data有2种写法</strong></p><p>​        (1).对象式</p><p>​        (2).函数式</p><p>​        如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p><p>​      <strong>3.一个重要的原则：</strong></p><p>​        由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p><h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a><strong>MVVM模型</strong></h3><p>​        1. M：模型(Model) ：data中的数据</p><p>​        2. V：视图(View) ：模板代码</p><p>​        3. VM：视图模型(ViewModel)：Vue实例</p><p>​     观察发现：</p><p>​        1.data中所有的属性，最后都出现在了vm身上。</p><p>​        2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a><strong>数据代理</strong></h3><p><strong>1.Vue中的数据代理：</strong>通过vm对象来代理data对象中属性的操作（读/写）</p><p><strong>2.Vue中数据代理的好处：</strong>更加方便的操作data中的数据</p><p><strong>3.基本原理：</strong></p><p>​         通过Object.defineProperty()把data对象中所有属性添加到vm上。</p><p>​         为每一个添加到vm上的属性，都指定一个getter/setter。</p><p>​         在getter/setter内部去操作（读/写）data中对应的属性。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a><strong>事件处理</strong></h3><p><strong>事件的基本使用：</strong></p><p>​      1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p><p>​      2.事件的回调需要配置在methods对象中，最终会在vm上；</p><p>​      3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p><p>​      4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p><p>​      5.@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参；</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a><strong>事件修饰符</strong></h3><p>​      1.prevent：阻止默认事件（常用）；（js原生阻止默认事件event.preventDefault）</p><p>​      2.stop：阻止事件冒泡（常用）；(js原生阻止事件冒泡event.stopPropagation)</p><p>​      3.once：事件只触发一次（常用）；</p><p>​      4.capture：使用事件的捕获模式,加在外部事件上；</p><p>​      5.self：只有event.target是当前操作的元素时才触发事件；</p><p>​      6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p><p>​       7.事件修饰符可以连续写  @click.prevent.stop= “demo”</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a><strong>键盘事件</strong></h3><p>1.Vue中常用的按键别名：</p><p>​         回车 =&gt; enter</p><p>​         删除 =&gt; delete (捕获“删除”和“退格”键)</p><p>​         退出 =&gt; esc</p><p>​         空格 =&gt; space</p><p>​         换行 =&gt; tab (特殊，必须配合keydown去使用)</p><p>​         上 =&gt; up</p><p>​         下 =&gt; down</p><p>​         左 =&gt; left</p><p>​         右 =&gt; right</p><p>   2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p><p>   3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p><p>​       (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p><p>​       (2).配合keydown使用：正常触发事件。</p><p> 4.也可以使用keyCode去指定具体的按键（不推荐）</p><p>5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p><p>6.可以组合指定比如：@keyup.ctrl.y 按下ctrl+y才会触发</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><strong>计算属性</strong></h3><p>​     <strong>1.定义：</strong>要用的属性不存在，要通过已有属性计算得来。</p><p>​     <strong>2.原理：</strong>底层借助了Objcet.defineproperty方法提供的getter和setter。</p><p>​     <strong>3.get函数什么时候执行？</strong></p><p>​         (1).初次读取时会执行一次。</p><p>​         (2).当依赖的数据发生改变时会被再次调用。</p><p>​     <strong>4.优势：</strong>与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>​     <strong>5.备注：</strong></p><p>​      (1).计算属性最终会出现在vm上，直接读取使用即可。</p><p>​       (2).如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p><h3 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a><strong>监视属性</strong></h3><p><strong>监视属性watch：</strong></p><p>​     1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p><p>​     2.监视的属性必须存在，才能进行监视！！</p><p>​     3.监视的两种写法：</p><p>​         (1).new Vue时传入watch配置</p><p>​         (2).通过vm.$watch监视</p><p><strong>深度监视：</strong></p><p>​      (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p><p>​      (2).配置deep:true可以监测对象内部值改变（多层）。</p><p> <strong>备注：</strong></p><p>​      (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p><p>​      (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p><p> <strong>配置项：</strong></p><p>​       immediate     让监视属性初始化时调用一下</p><p>​       deep  开启深度监视</p><h3 id="computed与watch之间的区别"><a href="#computed与watch之间的区别" class="headerlink" title="computed与watch之间的区别"></a><strong>computed与watch之间的区别</strong></h3><p><strong>computed和watch之间的区别：</strong></p><p>​       1.computed能完成的功能，watch都可以完成。</p><p>​        2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p><p><strong>两个重要的小原则：</strong></p><p>​       1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p><p>​       2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p><p>​    </p><h3 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a><strong>绑定样式</strong></h3><p>​      <strong>1. class样式</strong></p><p>​        写法:class=”xxx” xxx可以是字符串、对象、数组。</p><p>​            字符串写法适用于：类名不确定，要动态获取。</p><p>​            对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p><p>​            数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><p>​      <strong>2. style样式</strong></p><p>​        :style=”{fontSize: xxx}”其中xxx是动态值。</p><p>​        :style=”[a,b]”其中a、b是样式对象。</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a><strong>条件渲染</strong></h3><p>​       <strong>1.v-if</strong></p><p>​         写法：</p><p>​          (1).v-if=”表达式” </p><p>​          (2).v-else-if=”表达式”</p><p>​          (3).v-else=”表达式”</p><p>​         适用于：切换频率较低的场景。</p><p>​         特点：不展示的DOM元素直接被移除。</p><p>​         注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><p>​       <strong>2.v-show</strong></p><p>​         写法：v-show=”表达式”</p><p>​         适用于：切换频率较高的场景。</p><p>​         特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><p>​                </p><p>​       <strong>3.备注：</strong>使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p><p>​            &lt; template &gt;只能和v-if配合使用</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a><strong>列表渲染</strong></h3><p><strong>v-for指令:</strong></p><p>​      1.用于展示列表数据</p><p>​      2.语法：v-for=”(item, index) in xxx” :key=”yyy”</p><p>​      3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p><h3 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a><strong>Vue监视数据原理</strong></h3><ol><li><p>vue会监视data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？</p></li></ol><p>​        通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>​         (1).对象中后追加的属性，Vue默认不做响应式处理</p><p>​         (2).如需给后添加的属性做响应式，请使用如下API：</p><p>​              Vue.set(target，propertyName/index，value) 或 </p><p>​              vm.$set(target，propertyName/index，value)</p><ol start="3"><li>如何监测数组中的数据？</li></ol><p>​        通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>​         (1).调用原生对应的方法对数组进行更新。</p><p>​         (2).重新解析模板，进而更新页面。</p><p>   4.在Vue修改数组中的某个元素一定要用如下方法：</p><p>​        (1).使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​        (2).Vue.set() 或 vm.$set()</p><p>​    <span style="color:red"> 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</span></p><h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a><strong>收集表单数据</strong></h3><p>收集表单数据：</p><p>​    若：&lt; input type=”text”/ &gt;，则v-model收集的是value值，用户输入的就是value值。</p><p>​    若：&lt; input type=”radio”/ &gt;，则v-model收集的是value值，且要给标签配置value值。</p><p>​    若：&lt; input type=”checkbox”/ &gt;</p><p>​       1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​       2.配置input的value属性:</p><p>​         (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​         (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p><p>​    备注：v-model的三个修饰符：</p><p>​         lazy：失去焦点再收集数据</p><p>​         number：输入字符串转为有效的数字</p><p>​         trim：输入首尾空格过滤</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><strong>过滤器</strong></h3><p> <strong>定义：</strong>对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>  <strong>语法：</strong></p><p>​      1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p><p>​      2.使用过滤器：{ { xxx | 过滤器名} }  或  v-bind:属性 = “xxx | 过滤器名”</p><p>​     <strong>备注：</strong></p><p>​       1.过滤器也可以接收额外参数、多个过滤器也可以串联</p><p>​      2.并没有改变原本的数据, 是产生新的对应的数据</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a><strong>内置指令</strong></h3><p>  <strong>v-bind</strong> : 单向绑定解析表达式, 可简写为 :xxx</p><p>​        <strong>v-model</strong> : 双向数据绑定</p><p>​        <strong>v-for</strong>  : 遍历数组/对象/字符串</p><p>​        <strong>v-on</strong>   : 绑定事件监听, 可简写为@</p><p>​        <strong>v-if</strong>     : 条件渲染（动态控制节点是否存存在）</p><p>​        <strong>v-else</strong>  : 条件渲染（动态控制节点是否存存在）</p><p>​        <strong>v-show</strong>  : 条件渲染 (动态控制节点是否展示)</p><p>​       <strong>v-text</strong>指令：</p><p>​          1.作用：向其所在的节点中渲染文本内容。</p><p>​          2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p><p>​        <strong>v-html</strong>指令：</p><p>​          1.作用：向指定节点中渲染包含html结构的内容。</p><p>​          2.与插值语法的区别：</p><p>​            (1).v-html会替换掉节点中所有的内容，则不会。</p><p>​            (2).v-html可以识别html结构。</p><p>​         <span style="color:red"> 3.严重注意：v-html有安全性问题！！！！</span></p><p>​            (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p><p>​            (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p><p><strong>v-cloak</strong>指令（没有值）：</p><p>​          1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p><p>​          2.使用css配合v-cloak可以解决网速慢时页面展示出的问题。</p><p><strong>v-once</strong>指令：</p><p>​          1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p><p>​          2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><p><strong>v-pre</strong>指令：</p><p>​          1.跳过其所在节点的编译过程。</p><p>​          2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><strong>自定义指令</strong></h3><p> <strong>一、定义语法：</strong></p><p>​     (1).局部指令：</p><p>​       </p><pre class="line-numbers language-none"><code class="language-none">new Vue(&#123;directives:&#123;指令名: 配置对象&#125;&#125;)或new Vue(&#123;directives:&#123;指令名: 回调函数&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     (2).全局指令：</p><p>​       Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)</p><p><strong>二、配置对象中常用的3个回调：</strong></p><p>​     (1).bind：指令与元素成功绑定时调用。</p><p>​     (2).inserted：指令所在元素被插入页面时调用。</p><p>​     (3).update：指令所在模板结构被重新解析时调用。</p><p>​     </p><p>​     <strong>三、备注：</strong></p><p>​      1.指令定义时不加v-，但使用时要加v-；</p><p>​      2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p><img src="2022/04/08/vue2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期图"></p><p> 1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p><p>​     2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p><p>​      3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>​     4.生命周期函数中的this指向是vm 或 组件实例对象。</p><p>常用的生命周期钩子：</p><p>​     1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p><p>​     2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p><p>   关于销毁Vue实例</p><p>​     1.销毁后借助Vue开发者工具看不到任何信息。</p><p>​     2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p><p>​     3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a><strong>组件</strong></h3><p><em><strong>Vue中使用组件的三大步骤：</strong></em></p><p>​        一、定义组件(创建组件)</p><p>​        二、注册组件</p><p>​        三、使用组件(写组件标签)</p><p>​      <strong>一、如何定义一个组件？</strong></p><p>​         使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；区别如下：</p><p>​          1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</p><p>​          2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</p><p>​          备注：使用template可以配置组件结构。</p><p>​       <strong>二、如何注册组件？</strong></p><p>​          1.局部注册：靠new Vue的时候传入components选项</p><p>​          2.全局注册：靠Vue.component(‘组件名’,组件)</p><p>​       三、编写组件标签：  &lt; school &gt;&lt; /school &gt;</p><p><span style="color:red">关于VueComponent：</span></p><p>​      1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p><p>​      2.我们只需要写&lt; school/ &gt;或&lt; school &gt;&lt; /school &gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。</p><p>​    3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</p><p>​      4.关于this指向：</p><p>​        (1).组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</p><p>​        (2).new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p><p>5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。</p><p><strong>重要内置关系</strong>：</p><p>   1.一个重要的内置关系：VueComponent.prototype. _ _ proto _ _ === Vue.prototype</p><p>​     2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2022/03/21/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/03/21/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table>        <tr>                      <td>git --version</td>              <td>查看git版本</td>        </tr>         <tr>            <td>git init</td>            <td>初始化仓库</td>        </tr>        <tr>            <td>git config --global user.name xxx </td>            <td>设置用户签名</td>        </tr>        <tr>            <td>git config --global user.email xxx</td>            <td>设置用户邮箱</td>        </tr>        <tr>            <td>git status</td>            <td>查看文件状态</td>        </tr>        <tr>            <td>git add  <filename></filename></td>            <td>将文件添加到暂存区</td>        </tr>        <tr>            <td>ll</td>            <td>linux命令，查看工作区文件</td>        </tr>        <tr>            <td>clear</td>            <td>清空页面</td>        </tr>        <tr>            <td>git rm --cached  <filename></filename></td>            <td>删除暂存区文件</td>        </tr>        <tr>            <td>git commit -m “日志备注”  <filename></filename></td>            <td>将文件提交到本地库</td>        </tr>        <tr>            <td>git commit -a -m “备注” </td>            <td>-a可以将所有被修改或者已删除的且已经被git管理的文档提交到仓库中，注意-a不会造成新的文件被提交，只能修改</td>        </tr>        <tr>            <td>git reflog  / git log</td>            <td>查看版本信息</td>        </tr>        <tr>            <td>cat  <filename></filename></td>            <td>查看文件内容</td>        </tr>        <tr>            <td>vim  <filename></filename></td>            <td>修改文件内容 :wp 保存 :q!不保存退出 yy复制 p 粘贴 a进入编辑模式 Esc进入操作模式</td>        </tr>        <tr>            <td>git reset  --hard  <版本号> </版本号></td>            <td>版本穿梭</td>        </tr>        <tr>            <td>git branch -v </td>            <td>查看分支（*代表当前所在分支）</td>        </tr>        <tr>            <td>git branch  <分支名></分支名></td>            <td>创建分支</td>        </tr>        <tr>            <td>git branch -d  <分支名></分支名></td>            <td>删除一个分支</td>        </tr>        <tr>            <td>git checkout  <分支名></分支名></td>            <td>切换分支</td>        </tr>        <tr>            <td>git merge  <分支名></分支名></td>            <td>把指定的分支合并到当前分支上</td>        </tr>        <tr>            <td>冲突合并</td>            <td>两个分支修改同一个文件的同一个地方合并的时候会发生合并冲突解决办法：手动合并，vim打开文件将需要修改的地方手动修改一下，然后保存退出，再次添加暂存区，再次提交本库注意提交本地库时不要再加文件名称了（git commit -m “日志备注”）</td>        </tr>        <tr>            <td>git remote add <别名>  <远程仓库地址></远程仓库地址></别名></td>            <td>给远程仓库起别名</td>        </tr>        <tr>            <td>git remote -v</td>            <td>查看当前所有远程仓库地址的别名</td>        </tr>        <tr>            <td>git push <远程库地址或别名> <分支名></分支名></远程库地址或别名></td>            <td>往远程仓库推送</td>        </tr>        <tr>            <td>git pull  <远程库地址或别名> <分支名></分支名></远程库地址或别名></td>            <td>拉取远程仓库代码</td>        </tr>        <tr>            <td>git clone  <远程仓库地址></远程仓库地址></td>            <td>1、初始化本地仓库2、拉取代码创建别名（之前的别名git自动用origin代替）</td>        </tr>    </table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react扩展</title>
      <link href="/2022/01/27/react%E6%89%A9%E5%B1%95/"/>
      <url>/2022/01/27/react%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h3><h4 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h4><p>(1). setState(stateChange, [callback])——对象式的setState<br>            1.stateChange为状态改变对象(该对象可以体现出状态的更改)<br>            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</p><p>(2). setState(updater, [callback])——函数式的setState<br>        1.updater为返回stateChange对象的函数。<br>        2.updater可以接收到state和props。<br>        4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</p><p>总结:<br>        1.对象式的setState是函数式的setState的简写方式(语法糖)<br>        2.使用原则：<br>                (1).如果新状态不依赖于原状态 ===&gt; 使用对象方式<br>                (2).如果新状态依赖于原状态 ===&gt; 使用函数方式<br>                (3).如果需要在setState()执行后获取最新的状态数据,<br>                    要在第二个callback函数中读取</p><h3 id="2-lazyLoad"><a href="#2-lazyLoad" class="headerlink" title="2. lazyLoad"></a>2. lazyLoad</h3><h4 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h4><p>1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包<br>const Login = lazy(()=&gt;import(‘@/pages/Login’))</p><p>2.通过&lt; Suspense &gt;指定在加载得到路由打包文件前显示一个自定义loading界面</p><pre class="line-numbers language-none"><code class="language-none">&lt;Suspense fallback&#x3D;&#123;&lt; h1 &gt;loading.....&lt;&#x2F; h1 &gt;&#125;&gt;    &lt; Switch &gt;        &lt; Route path&#x3D;&quot;&#x2F;xxx&quot; component&#x3D;&#123;Xxxx&#125;&#x2F; &gt;        &lt;Redirect to&#x3D;&quot;&#x2F;login&quot;&#x2F; &gt;    &lt; &#x2F;Switch &gt;&lt; &#x2F;Suspense &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h3><h4 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook/Hooks是什么?"></a>1. React Hook/Hooks是什么?</h4><p>(1). Hook是React 16.8.0版本增加的新特性/新语法<br>(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</p><h4 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h4><p>(1). State Hook: React.useState()<br>(2). Effect Hook: React.useEffect()<br>(3). Ref Hook: React.useRef()</p><h4 id="3-State-Hook"><a href="#3-State-Hook" class="headerlink" title="3. State Hook"></a>3. State Hook</h4><p>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作<br>(2). 语法: const [xxx, setXxx] = React.useState(initValue)<br>(3). useState()说明:<br>        参数: 第一次初始化指定的值在内部作缓存<br>        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数<br>(4). setXxx()2种写法:<br>        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值<br>        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</p><h4 id="4-Effect-Hook"><a href="#4-Effect-Hook" class="headerlink" title="4. Effect Hook"></a>4. Effect Hook</h4><p>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)<br>(2). React中的副作用操作:<br>        发ajax请求数据获取<br>        设置订阅 / 启动定时器<br>        手动更改真实DOM<br>(3). 语法和说明: </p><pre class="line-numbers language-none"><code class="language-none">useEffect(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 在此可以执行任何带副作用操作    return () &#x3D;&gt; &#123; &#x2F;&#x2F; 在组件卸载前执行      &#x2F;&#x2F; 在此做一些收尾工作, 比如清除定时器&#x2F;取消订阅等    &#125;  &#125;, [stateValue]) &#x2F;&#x2F; 如果指定的是[], 回调函数只会在第一次render()后执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4). 可以把 useEffect Hook 看做如下三个函数的组合<br>        componentDidMount()<br>        componentDidUpdate()<br>        componentWillUnmount() </p><h4 id="5-Ref-Hook"><a href="#5-Ref-Hook" class="headerlink" title="5. Ref Hook"></a>5. Ref Hook</h4><p>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据<br>(2). 语法: const refContainer = useRef()<br>(3). 作用:保存标签对象,功能与React.createRef()一样</p><h3 id="4-Context"><a href="#4-Context" class="headerlink" title="4. Context"></a>4. Context</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">1. 创建Context容器对象：   const XxxContext &#x3D; React.createContext()  2. 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：   &lt;xxxContext.Provider value&#x3D;&#123;数据&#125;&gt;   子组件    &lt;&#x2F;xxxContext.Provider&gt;3. 后代组件读取数据：   &#x2F;&#x2F;第一种方式:仅适用于类组件      static contextType &#x3D; xxxContext  &#x2F;&#x2F; 声明接收context     this.context &#x2F;&#x2F; 读取context中的value数据   &#x2F;&#x2F;第二种方式: 函数组件与类组件都可以     &lt;xxxContext.Consumer&gt;       &#123;         value &#x3D;&gt; ( &#x2F;&#x2F; value就是context中的value数据           要显示的内容         )       &#125;     &lt;&#x2F;xxxContext.Consumer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在应用开发中一般不用context, 一般都用它的封装react插件</p><h3 id="5-组件优化"><a href="#5-组件优化" class="headerlink" title="5. 组件优化"></a>5. 组件优化</h3><h4 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h4><ol><li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render() ==&gt; 效率低</p></li><li><p>只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==&gt; 效率低</p></li></ol><h4 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h4><p>只有当组件的state或props数据发生改变时才重新render()</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>Component中的shouldComponentUpdate()总是返回true</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>办法1:<br>    重写shouldComponentUpdate()方法<br>    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false<br>办法2:<br>    使用PureComponent<br>    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true<br>    注意:<br>        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false<br>        不要直接修改state数据, 而是要产生新数据<br>项目中一般使用PureComponent来优化</p><h3 id="6-render-props"><a href="#6-render-props" class="headerlink" title="6. render props"></a>6. render props</h3><h4 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h4><p>Vue中:<br>    使用slot技术, 也就是通过组件标签体传入结构  &lt; A &gt;&lt; B/&gt;&lt; /A&gt;<br>React中:<br>    使用children props: 通过组件标签体传入结构<br>    使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性</p><h4 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h4><pre class="line-numbers language-none"><code class="language-none">&lt;A&gt;  &lt;B&gt;xxxx&lt;&#x2F;B&gt;&lt;&#x2F;A&gt;&#123;this.props.children&#125;问题: 如果B组件需要A组件内的数据, &#x3D;&#x3D;&gt; 做不到 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h4><p>&lt;A render={(data) =&gt; &lt; C data={data}&gt;&lt; /C &gt;}&gt;&lt; /A&gt;<br>A组件: {this.props.render(内部state数据)}<br>C组件: 读取A组件传入的数据显示 {this.props.data} </p><h3 id="7-错误边界"><a href="#7-错误边界" class="headerlink" title="7. 错误边界"></a>7. 错误边界</h3><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p><strong>getDerivedStateFromError配合componentDidCatch</strong></p><p>生命周期函数，一旦后台组件报错，就会触发</p><pre class="line-numbers language-none"><code class="language-none">static getDerivedStateFromError(error) &#123;    console.log(error);    &#x2F;&#x2F;在render之前触发    &#x2F;&#x2F;返回新的state    return &#123;        hasError: true,    &#125;;&#125;componentDidCatch(error, info) &#123;     &#x2F;&#x2F;统计页面的错误。发送请求发送到后台去    console.log(error, info);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-组件通信方式总结"><a href="#8-组件通信方式总结" class="headerlink" title="8. 组件通信方式总结"></a>8. 组件通信方式总结</h3><h4 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h4><ul><li>父子组件</li><li>兄弟组件（非嵌套组件）</li><li>祖孙组件（跨级组件）</li></ul><h4 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h4><h5 id="1-props："><a href="#1-props：" class="headerlink" title="1.props："></a>1.props：</h5><p>​    (1).children props<br>​    (2).render props</p><h5 id="2-消息订阅-发布："><a href="#2-消息订阅-发布：" class="headerlink" title="2.消息订阅-发布："></a>2.消息订阅-发布：</h5><p>​    pubs-sub、event等等</p><h5 id="3-集中式管理："><a href="#3-集中式管理：" class="headerlink" title="3.集中式管理："></a>3.集中式管理：</h5><p>​    redux、dva等等</p><h5 id="4-conText"><a href="#4-conText" class="headerlink" title="4.conText:"></a>4.conText:</h5><p>​    生产者-消费者模式</p><h4 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h4><p>​    父子组件：props<br>​    兄弟组件：消息订阅-发布、集中式管理<br>​    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux</title>
      <link href="/2022/01/18/redux/"/>
      <url>/2022/01/18/redux/</url>
      
        <content type="html"><![CDATA[<h4 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h4><h5 id="redux是什么"><a href="#redux是什么" class="headerlink" title="redux是什么"></a>redux是什么</h5><p>​                        1. redux是一个专门用于做<strong>状态管理</strong>的JS库(不是react插件库)。</p><p>​                        2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p><p>​                        3. 作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</p><h5 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h5><p>​                        1. 某个组件的状态，需要让其他组件可以随时拿到（共享）。</p><p>​                        2. 一个组件需要改变另一个组件的状态（通信）。</p><p>​                        3. 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。</p><h5 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h5><p>​                    <img src="/2022/01/18/redux/redux.png" alt="redux"></p><h4 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h4><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><p>​                1. 动作的对象</p><p>​                2. 包含2个属性</p><p>​                        type：标识属性, 值为字符串, 唯一, 必要属性</p><p>​                        data：数据属性, 值类型任意, 可选属性</p><p>​                3. 例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</p><h5 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h5><p>​                1. 用于初始化状态、加工状态。</p><p>​                2. 加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</p><h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><p>​                1. 将state、action、reducer联系在一起的对象</p><p>​                2. 如何得到此对象?</p><p>​                       (1) import {createStore} from ‘redux’</p><p>​                       (2) import reducer from ‘./reducers’</p><p>​                       (3) const store = createStore(reducer)</p><p>​                3. 此对象的功能?</p><p>​                       (1) getState(): 得到state</p><p>​                       (2) dispatch(action): 分发action, 触发reducer调用, 产生新的state</p><p>​                       (3) subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p><h4 id="redux的核心API"><a href="#redux的核心API" class="headerlink" title="redux的核心API"></a>redux的核心API</h4><h5 id="createstore"><a href="#createstore" class="headerlink" title="createstore()"></a>createstore()</h5><p>​                   作用：创建包含指定reducer的store对象</p><h5 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h5><p>​                    1. 作用: redux库最核心的管理对象</p><p>​                    2. 它内部维护着:</p><p>​                                     (1) state</p><p>​                                     (2) reducer</p><p>​                    3. 核心方法:</p><p>​                                     (1) getState()</p><p>​                                     (2) dispatch(action)</p><p>​                                     (3) subscribe(listener)</p><p>​                    4. 具体编码:</p><p>​                                     (1) store.getState()</p><p>​                                     (2) store.dispatch({type:’INCREMENT’, number})</p><p>​                                     (3) store.subscribe(render)</p><h5 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware()"></a>applyMiddleware()</h5><p>​                   作用：应用上基于redux的中间件(插件库)</p><h5 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers()"></a>combineReducers()</h5><p>​                   作用：合并多个reducer函数</p><h4 id="redux异步编程"><a href="#redux异步编程" class="headerlink" title="redux异步编程"></a>redux异步编程</h4><h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>​                   1. redux默认是不能进行异步处理的 </p><p>​                   2. 某些时候应用中需要在<strong>redux中执行异步任务</strong>(ajax, 定时器)</p><h5 id="使用异步中间件"><a href="#使用异步中间件" class="headerlink" title="使用异步中间件"></a>使用异步中间件</h5><p>​                   npm install –save redux-thunk</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯函数、高阶函数、函数柯里化</title>
      <link href="/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2022/01/16/%E7%BA%AF%E5%87%BD%E6%95%B0%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="纯函数、高阶函数、函数柯里化"><a href="#纯函数、高阶函数、函数柯里化" class="headerlink" title="纯函数、高阶函数、函数柯里化"></a>纯函数、高阶函数、函数柯里化</h4><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>​            1. 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)</p><p>​            2. 必须遵守以下一些约束 </p><p>​                           (1) 不得改写参数数据</p><p>​                           (2) 不会产生任何副作用，例如网络请求，输入和输出设备</p><p>​                           (3) 不能调用Date.now()或者Math.random()等不纯的方法 </p><p>​            3. redux的reducer函数必须是一个纯函数</p><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>​            1. 理解: 一类特别的函数</p><p>​                    (1) 情况1: 参数是函数</p><p>​                    (2) 情况2: 返回是函数</p><p>​            2. 常见的高阶函数: </p><p>​                    (1) 定时器设置函数</p><p>​                    (2) 数组的forEach()/map()/filter()/reduce()/find()/bind()</p><p>​                    (3) promise</p><p>​                    (4) react-redux中的connect函数</p><p>​             3. 作用: 能实现更加动态, 更加可扩展的功能</p><h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><p>​            函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 </p><p>​          </p><pre class="line-numbers language-none"><code class="language-none">function sum(a)&#123;          return  (b)&#x3D;&gt;&#123;                  return  (c)&#x3D;&gt;&#123;                         return a+b+c                         &#125;                  &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux</title>
      <link href="/2022/01/16/react-redux/"/>
      <url>/2022/01/16/react-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​            1. 一个react插件库</p><p>​            2. 专门用来简化react应用中使用redux</p><h4 id="react-Redux将所有组件分成两大类"><a href="#react-Redux将所有组件分成两大类" class="headerlink" title="react-Redux将所有组件分成两大类"></a>react-Redux将所有组件分成两大类</h4><p>​            1. UI组件</p><p>​                  (1) 只负责 UI 的呈现，不带有任何业务逻辑</p><p>​                  (2) 通过props接收数据(一般数据和函数)</p><p>​                  (3) 不使用任何 Redux 的 API</p><p>​                  (4) 一般保存在components文件夹下</p><p>​            2. 容器组件</p><p>​                  (1) 负责管理数据和业务逻辑，不负责UI的呈现</p><p>​                  (2) 使用 Redux 的 API</p><p>​                  (3) 一般保存在containers文件夹下</p><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><p>​                 1. Provider：让所有组件都可以得到state数据</p><p>​                 2. connect：用于包装 UI 组件生成容器组件</p><p>​                 3. mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性</p><p>​                 4. mapDispatchToProps：将分发action的函数转换为UI组件的标签属性</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react路由</title>
      <link href="/2022/01/16/react%E8%B7%AF%E7%94%B1/"/>
      <url>/2022/01/16/react%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h4><p>​                1. 单页Web应用（single page web application，SPA）。</p><p>​                2. 整个应用只有<strong>一个完整的页面</strong>。</p><p>​                3. 点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</p><p>​                4. 数据都需要通过ajax请求获取, 并在前端异步展现。</p><h4 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h4><h5 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由?"></a>1.什么是路由?</h5><p>​                          (1). 一个路由就是一个映射关系(key:value)</p><p>​                          (2). key为路径, value可能是function或component</p><h5 id="2-路由分类"><a href="#2-路由分类" class="headerlink" title="2.路由分类"></a>2.路由分类</h5><h6 id="1-后端路由："><a href="#1-后端路由：" class="headerlink" title="(1). 后端路由："></a>(1). 后端路由：</h6><p>​                           (1) 理解： value是function, 用来处理客户端提交的请求。</p><p>​                           (2) 注册路由： router.get(path, function(req, res))</p><p>​                           (3) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p><h6 id="2-前端路由："><a href="#2-前端路由：" class="headerlink" title="(2). 前端路由："></a>(2). 前端路由：</h6><p>​                           (1) 浏览器端路由，value是component，用于展示页面内容。</p><p>​                           (2) 注册路由: &lt; Route path=”/test” component={Test} &gt;</p><p>​                           (3) 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p><h4 id="react-router-dom的理解"><a href="#react-router-dom的理解" class="headerlink" title="react-router-dom的理解"></a>react-router-dom的理解</h4><p>​                           (1). react的一个插件库。</p><p>​                           (2). 专门用来实现一个SPA应用。</p><p>​                           (3). 基于react的项目基本都会用到此库。</p><h4 id="react-router-dom相关API"><a href="#react-router-dom相关API" class="headerlink" title="react-router-dom相关API"></a><strong>react-router-dom相关API</strong></h4><h5 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h5><p>​                        1. &lt; BrowserRouter &gt;</p><p>​                        2. &lt; HashRouter &gt;</p><p>​                        3. &lt; Route &gt;</p><p>​                        4. &lt; Redirect &gt;</p><p>​                        5. &lt; Link &gt;</p><p>​                        6. &lt; NavLink &gt;</p><p>​                        7. &lt; Switch &gt;</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>​                        1. history对象</p><p>​                        2. match对象</p><p>​                        3. withRouter函数        </p><h4 id="基本路由使用"><a href="#基本路由使用" class="headerlink" title="基本路由使用"></a>基本路由使用</h4><p>​                       1. 下载 react-router-dom:  npm install –save react-router-dom</p><p>​                       2. 引入bootstrap.css: &lt; link rel=”stylesheet” href=”/css/bootstrap.css” &gt;</p><p>​                                (1).明确好界面中的导航区、展示区</p><p>​                                (2).导航区的a标签改为Link标签&lt; Link to=”/xxxxx” &gt;Demo&lt;/ Link &gt;</p><p>​                                (3).展示区写Route标签进行路径的匹配&lt; Route path=’/xxxx’ component={Demo}/ &gt;</p><p>​                                (4).&lt; App &gt;的最外侧包裹了一个&lt; BrowserRouter &gt;或&lt; HashRouter &gt;</p><h4 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h4><p>​                         1.写法不同：</p><p>​                                     一般组件：&lt; Demo/ &gt;</p><p>​                                    路由组件：&lt; Route path=”/demo” component={Demo}/ &gt;</p><p>​                          2.存放位置不同：</p><p>​                                            一般组件：components</p><p>​                                            路由组件：pages</p><p>​                         3.接收到的props不同：</p><p>​                                            一般组件：写组件标签时传递了什么，就能收到什么</p><p>​                                            路由组件：接收到三个固定的属性history、location、match</p><h4 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a><strong>NavLink与封装NavLink</strong></h4><p>​                              1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</p><h4 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a><strong>Switch的使用</strong></h4><p>​    1.通常情况下，path和component是一一对应的关系。</p><p>​    2.Switch可以提高路由匹配效率(单一匹配)。</p><h4 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a><strong>解决多级路径刷新页面样式丢失的问题</strong></h4><p>​     1.public/index.html 中 引入样式时不写 ./ 写 / （常用）</p><p>​        2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）</p><p>​        3.使用HashRouter</p><h4 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a><strong>路由的严格匹配与模糊匹配</strong></h4><p>​    1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</p><p>​        2.开启严格匹配：&lt; Route exact={true} path=”/about” component={About} &gt;</p><p>​        3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</p><h4 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a><strong>Redirect的使用</strong></h4><p> 1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由</p><h4 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a><strong>向路由组件传递参数</strong></h4><p> <strong>1.params参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=’/demo/test/tom/18’} &gt;详情&lt; /Link &gt;</p><p>​              注册路由(声明接收)：&lt; Route path=”/demo/test/:name/:age” component={Test}/ &gt;</p><p>​              接收参数：this.props.match.params</p><p>​        <strong>2.search参数</strong></p><p>​              路由链接(携带参数)：&lt;Link to=’/demo/test?name=tom&amp;age=18’}&gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.search</p><p>​              备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p><p>​       <strong>3.state参数</strong></p><p>​              路由链接(携带参数)：&lt; Link to=*{* **{**pathname:’/demo/test’,state:{name:’tom’,age:18}**}** *}* &gt;详情&lt; /Link &gt;</p><p>​              注册路由(无需声明，正常注册即可)：&lt; Route path=”/demo/test” component={Test}/ &gt;</p><p>​              接收参数：this.props.location.state</p><p>​              备注：刷新也可以保留住参数</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-ajax</title>
      <link href="/2022/01/16/react-ajax/"/>
      <url>/2022/01/16/react-ajax/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​     1. React本身只关注于界面, 并不包含发送ajax请求的代码</p><p>​     2. 前端应用需要通过ajax请求与后台进行交互(json数据)</p><p>​     3. react应用中需要集成第三方ajax库(或自己封装)</p><h3 id="常用的ajax请求库"><a href="#常用的ajax请求库" class="headerlink" title="常用的ajax请求库"></a>常用的ajax请求库</h3><p>​       1. jQuery: 比较重, 如果需要另外引入不建议使用</p><p>​       2. axios: 轻量级, 建议使用</p><p>​                 (1) 封装XmlHttpRequest对象的ajax</p><p>​                 (2) promise风格</p><p>​                 (3) 可以用在浏览器端和node服务器端</p><h3 id="消息订阅-发布机制"><a href="#消息订阅-发布机制" class="headerlink" title="消息订阅-发布机制"></a>消息订阅-发布机制</h3><p>​      1. 工具库: PubSubJS</p><p>​      2. 下载: npm install pubsub-js –save </p><p>​      3. 使用: </p><p>​              (1) import PubSub from ‘pubsub-js’ //引入</p><p>​              (2) PubSub.subscribe(‘delete’, function(data){ }); //订阅</p><p>​              (3) PubSub.publish(‘delete’, data) //发布消息</p><h3 id="扩展：Fetch"><a href="#扩展：Fetch" class="headerlink" title="扩展：Fetch"></a>扩展：Fetch</h3><h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>​            1. <a href="https://github.github.io/fetch/">https://github.github.io/fetch/</a></p><p>​            2. <a href="https://segmentfault.com/a/1190000003810652">https://segmentfault.com/a/1190000003810652</a></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>​              1. fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求</p><p>​              2. 老版本浏览器可能不支持</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架</title>
      <link href="/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/01/16/react%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h3><p>​            1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目</p><p>​                     (1). 包含了所有需要的配置（语法检查、jsx编译、devServer…）</p><p>​                     (2). 下载好了所有相关的依赖</p><p>​                     (3). 可以直接运行一个简单效果</p><p>​            2. react提供了一个用于创建react项目的脚手架库: create-react-app</p><p>​            3. 项目的整体技术架构为:  react + webpack + es6 + eslint</p><p>​            4. 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化</p><h5 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h5><p>​                    <strong>第一步</strong>，全局安装：npm i -g create-react-app</p><p>​                    <strong>第二步</strong>，切换到想创项目的目录，使用命令：create-react-app hello-react</p><p>​                    <strong>第三步</strong>，进入项目文件夹：cd hello-react</p><p>​                    <strong>第四步</strong>，启动项目：npm start</p><h4 id="react脚手架项目结构"><a href="#react脚手架项目结构" class="headerlink" title="react脚手架项目结构"></a>react脚手架项目结构</h4><p>​            public —- 静态资源文件夹</p><p>​                            favicon.icon —— 网站页签图标</p><p>​                            <strong>index.html ——– 主页面</strong></p><p>​                            logo192.png ——- logo图</p><p>​                            logo512.png ——- logo图</p><p>​                            manifest.json —– 应用加壳的配置文件</p><p>​                            robots.txt ——– 爬虫协议文件</p><p>​            src —- 源码文件夹</p><p>​                           App.css ——– App组件的样式</p><p>​                           <strong>App.js ——— App组件</strong></p><p>​                           App.test.js —- 用于给App做测试</p><p>​            index.css —— 样式</p><p>​                            <strong>index.js —— 入口文件</strong></p><p>​                            logo.svg ——- logo图</p><p>​                            reportWebVitals.js — 页面性能分析文件(需要web-vitals库的支持)</p><p>​                            setupTests.js</p><h4 id="功能界面的组件化编码流程（通用）"><a href="#功能界面的组件化编码流程（通用）" class="headerlink" title="功能界面的组件化编码流程（通用）"></a>功能界面的组件化编码流程（通用）</h4><p>​     1. 拆分组件: 拆分界面,抽取组件</p><p>​     2. 实现静态组件: 使用组件实现静态页面效果</p><p>​     3. 实现动态组件</p><p>​                   (1) 动态显示初始化数据</p><p>​                              ① 数据类型</p><p>​                              ② 数据名称</p><p>​                              ③ 保存在哪个组件?</p><p>​                   (2)交互(从绑定事件监听开始)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-jsx</title>
      <link href="/2022/01/14/react-jsx/"/>
      <url>/2022/01/14/react-jsx/</url>
      
        <content type="html"><![CDATA[<ol><li><p>全称:  JavaScript XML</p></li><li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是 <strong>React.createElement(component,props,…children)</strong> 方法的语法糖</p></li><li><p>作用: 用来简化创建虚拟DOM </p></li></ol><p>​         (1) 写法：<strong>var  ele = &lt; h3 &gt; hello,jsx!&lt; /h3 &gt;</strong></p><p>​         (2) 注意1：它不是字符串, 也不是HTML/XML标签</p><p>​         (3) 注意2：它最终产生的就是一个JS对象</p><ol start="4"><li><p>标签名任意: HTML标签或其它标签</p></li><li><p>标签属性任意: HTML标签属性或其它</p></li><li><p>基本语法规则</p><p>(1). 遇到 &lt;开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</p><p>(2).遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含</p><p>(3).定义虚拟DOM时，不要写引号</p><p>(4).样式的类名指定不要用class，要用className</p><p>(5).内联样式，要用style= <strong>{</strong>{key:value}<strong>}</strong> 的形式去写</p><p>(6).只有一个根标签</p><p>(7).标签必须闭合</p><p>(8).标签首字母</p><p>​         ①.若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错</p><p>​         ②.若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中key的作用</title>
      <link href="/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/01/14/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题:"></a>经典面试题:</h3><p>   <em>一. react/vue中的key有什么作用？（key的内部原理是什么？）</em></p><p>   <em>二. 为什么遍历列表时，key最好不要用index?</em></p><p>​    <strong>1. 虚拟DOM中key的作用：</strong></p><p>​      （1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p><p>​      （2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>​                 ①. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>​                         a.若虚拟DOM中内容没变, 直接使用之前的真实DOM</p><p>​                         b.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>​                 ②. 旧虚拟DOM中未找到与新虚拟DOM相同的key根据数据创建新的真实DOM，随后渲染到到页面</p><p>​    <strong>2.用index作为key可能会引发的问题：</strong></p><p>​       (1). 若对数据进行：逆序添加、逆序删除等破坏顺序操作,会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p><p>​       (2). 如果结构中还包含输入类的DOM,会产生错误DOM更新 ==&gt; 界面有问题。</p><p>​       (3). 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><p>​          </p><p>​    <strong>3. 开发中如何选择key:</strong></p><p>​      (1).最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p><p>​      (2).如果确定只是简单的展示数据，用index也是可以的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react生命周期</title>
      <link href="/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/01/14/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>​        1. 组件从创建到死亡它会经历一些特定的阶段。</p><p>​        2. React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。</p><p>​        3. 我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</p><h3 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h3><p><img src="/2022/01/14/react生命周期/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>生命周期的三个阶段</p><p>​           <strong>1.初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p><p>​                            (1). constructor()</p><p>​                            (2).getDerivedStateFromProps</p><p>​                            (3). render()</p><p>​                            (4). componentDidMount()</p><p>​           <strong>2.更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p><p>​                            (1).getDerivedStateFromProps</p><p>​                            (2). shouldComponentUpdate()</p><p>​                            (3). render()</p><p>​                            (4). getSnapshotBeforeUpdate</p><p>​                            (5). componentDidUpdate()</p><p>​           <strong>3.卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发</p><p>​                            (1). componentWillUnmount()</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件的三大核心属性</title>
      <link href="/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/01/13/react%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>​                        1. state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</p><p>​                        2. 组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</p><h4 id="强烈注意"><a href="#强烈注意" class="headerlink" title="强烈注意"></a>强烈注意</h4><p>​                        1. 组件中render方法中的this为组件实例对象</p><p>​                        2. 组件自定义的方法中this为undefined，如何解决？</p><p>​                                 ① 强制绑定this: 通过函数对象的bind()</p><p>​                                 ② 箭头函数</p><p>​                        3. 状态数据，不能直接修改或更新</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>​                       1. 每个组件对象都会有props(properties的简写)属性</p><p>​                       2. 组件标签的所有属性都保存在props中</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​                       1. 通过标签属性从组件外向组件内传递变化的数据</p><p>​                       2. 注意: 组件内部不要修改props数据</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>​                       1. 内部读取某个属性值</p><p>​                                <strong>this.props.name</strong></p><p>​                       2. 对props中的属性值进行类型限制和必要性限制</p><p>​                                使用prop-types库进限制（需要引入prop-types库）</p><p>​                                        <strong>Person.propTypes = {</strong></p><p>​                                                <strong>name: PropTypes.string.isRequired,</strong></p><p>​                                                <strong>age: PropTypes.number</strong></p><p>​                                        <strong>}</strong></p><p>​                       3. 扩展属性: 将对象的所有属性通过props传递</p><p>​                                <strong>&lt;Person {…person}/&gt;</strong></p><p>​                       4.默认属性值</p><p>​                                   <strong>Person.defaultProps = {</strong></p><p>​                                            <strong>age: 18,</strong></p><p>​                                            <strong>sex: “男”</strong></p><p>​                                    <strong>}</strong></p><p>​                       5.组件类的构造函数</p><p>​                                   <strong>constructor(props){</strong></p><p>​                                         <strong>super(props)</strong>    </p><p>​                                    <strong>}</strong></p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><p>​                      组件内的标签可以定义ref属性来标识自己</p><h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><p>​                    1.字符串形式的ref         </p><p>​                                    <strong>&lt; input ref=”input1”/ &gt;</strong>                </p><p>​                    2.回调形式的ref</p><p>​                                    <strong>&lt;input ref={(c)=&gt;{this.input1 = c}}/&gt;</strong>        </p><p>​                    3.create创建ref容器</p><p>​                                    <strong>myRef = React.createRef()</strong></p><p>​                                    <strong>&lt; input ref={this.myRef}/ &gt;</strong>        </p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>​        1. 通过onXxx属性指定事件处理函数(注意大小写)</p><p>​                （1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</p><p>​                （2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</p><p>​       2. 通过event.target得到发生事件的DOM元素对象</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块与组件、模块化与组件化的理解</title>
      <link href="/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/01/13/%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    1. 理解：向外提供特定功能的js程序, 一般就是一个js文件</p><p>​    2. 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。</p><p>​    3. 作用：复用js, 简化js的编写, 提高js运行效率</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>​    1. 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)</p><p>​    2. 为什么要用组件： 一个界面的功能更复杂</p><p>​    3. 作用：复用编码, 简化项目编码, 提高运行效率</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    当应用的js都以模块来编写的, 这个应用就是一个模块化的应用</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>​    当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react介绍描述</title>
      <link href="/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/"/>
      <url>/2022/01/13/react%E4%BB%8B%E7%BB%8D%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍描述"><a href="#介绍描述" class="headerlink" title="介绍描述"></a>介绍描述</h3><ol><li><p>用于动态构建用户界面的 JavaScript 库(只关注于视图)</p></li><li><p>由Facebook开源</p></li></ol><h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol><li><p>声明式编码</p></li><li><p>组件化编码</p></li><li><p>React Native 编写原生应用</p></li><li><p>高效（优秀的Diffing算法）</p></li></ol><h3 id="React高效的原因"><a href="#React高效的原因" class="headerlink" title="React高效的原因"></a>React高效的原因</h3><ol><li><p>使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。</p></li><li><p>DOM Diffing算法, 最小化页面重绘。</p></li></ol><h3 id="虚拟DOM与真实DOM"><a href="#虚拟DOM与真实DOM" class="headerlink" title="虚拟DOM与真实DOM"></a>虚拟DOM与真实DOM</h3><ol><li><p>React提供了一些API来创建一种 “特别” 的一般js对象</p><p><strong>const    VDOM = React.createElement(‘xx’,{id:’xx’},’xx’)</strong></p><p>上面创建的就是一个简单的虚拟DOM对象</p></li><li><p>虚拟DOM对象最终都会被React转换为真实的DOM</p></li><li><p>我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
